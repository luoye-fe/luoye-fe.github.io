<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LUOYE</title><meta name="description" content="luoye, blog, coder"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="https://s10.mogucdn.com/mlcdn/c45406/181108_569k3hlic06fcbj3i96b426i024d9.ico"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="stylesheet" href="/blog/css/prism.css"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="https://s10.mogucdn.com/mlcdn/c45406/180104_87747584h81ji8hjc144bkgkgk9ai_460x460.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="https://luoyefe.com" target="_blank" class="nav-list-link">INDEX</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/luo-ye-42-22" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="https://github.com/luoye-fe" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2021/02/05/一维码、二维码的生成原理/" class="post-title-link">一维码、二维码的生成原理</a></h2><div class="post-info">2021年2月5日</div><div class="post-content"><p>讲一讲一维码、二维码的生成原理，长文预警！</p>
<h2 id="一维码"><a href="#一维码" class="headerlink" title="一维码"></a>一维码</h2><p>barcode 白皮书：<a href="https://www.barcodefaq.com/1d/code-128/" target="_blank" rel="noopener">https://www.barcodefaq.com/1d/code-128/</a></p>
<p>一维码即条形码，由多个黑白条纹组成，基本原理就是通过二进制表示各个 ASCII 字符，以最常见最通用的 code128-B 码制为例（code128 可以表示全部的128个 ASCII 字符）</p>
<blockquote>
<p>UPC 码制是国际商品条码标准，这里不讨论商品码生成的规则，下文的条形码示例用微信、支付宝的扫码工具无法识别（微信、支付宝识别的是 UPC 码，用于查询商品信息），可以用钉钉扫码测试。</p>
</blockquote>
<p>条形码中，黑看做1，白看做0，code128-B 条形码的规律如下：</p>
<br></div><a href="/blog/2021/02/05/一维码、二维码的生成原理/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2020/12/18/折腾折腾家庭网络架构/" class="post-title-link">折腾折腾家庭网络架构</a></h2><div class="post-info">2020年12月18日</div><div class="post-content"><h2 id="先上图"><a href="#先上图" class="headerlink" title="先上图"></a>先上图</h2><blockquote>
<p>全屏，放大，看细节</p>
</blockquote>
<p></p>
<h2 id="来吧，展示"><a href="#来吧，展示" class="headerlink" title="来吧，展示"></a>来吧，展示</h2><ul>
<li><p>聚阅：<a href="http://render.luoyefe.com/juyue" target="_blank" rel="noopener">http://render.luoyefe.com/juyue</a></p>
</li>
<br></ul></div><a href="/blog/2020/12/18/折腾折腾家庭网络架构/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2020/12/18/NPM-的基础知识/" class="post-title-link">NPM 的基础知识</a></h2><div class="post-info">2020年12月18日</div><div class="post-content"><h2 id="npm-的安装"><a href="#npm-的安装" class="headerlink" title="npm 的安装"></a>npm 的安装</h2><p>作为 <code>NodeJS</code> 的包管理工具， 安装 <code>NodeJS</code> 的过程中， <code>npm</code> 就会自动安装，而安装 <code>NodeJS</code> 的方法一般有三种：</p>
<ul>
<li><p><strong>官网安装包</strong></p>
<p>官方已经为各个系统构架好安装包，访问 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 根据系统下载安装即可。</p>
</li>
<li><p><strong>编译安装</strong></p>
<p>如果想要体验 <code>NodeJS</code> 最新特性，可以从源码编译安装，较为复杂，需 clone 源码并安装整套的编译工具，具 体可访问 <a href="https://github.com/nodejs/node/blob/master/BUILDING.md" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/master/BUILDING.md</a>，这里不展开。</p>
<br></li></ul></div><a href="/blog/2020/12/18/NPM-的基础知识/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2020/09/21/JS-新特性：Temporal/" class="post-title-link">JS 新特性：Temporal</a></h2><div class="post-info">2020年9月21日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日（2020.9.16）， <code>Moment</code> 团队发布<a href="https://momentjs.com/docs/#/-project-status/recommendations/" target="_blank" rel="noopener">声明</a>，宣布 <code>Moment</code> 将进入<strong>维护状态</strong>，除非必要，将不再更新：</p>
<ul>
<li>未来不会新增任何新特性</li>
<li>不会改成 <code>immutable</code> </li>
<li>不会做 <code>tree shakeing</code> ，也不会解决包体积问题</li>
<li>不会更新 v3 版本</li>
<li>不会修复 bug 或非预期行为，特别是长期以来的已知问题</li>
<br></ul></div><a href="/blog/2020/09/21/JS-新特性：Temporal/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2020/07/02/深挖-css-垂直居中的实现/" class="post-title-link">深挖 css 垂直居中的实现</a></h2><div class="post-info">2020年7月2日</div><div class="post-content"><blockquote>
<p>请说说如何实现垂直居中？</p>
</blockquote>
<p>前端面试，垂直居中总是一个绕不开的问题，在座的各位可能可以说出不下10种解决方案，最常见的 flex、margin、绝对定位，「复古」一点的用 padding、vertical-align，甚至伪类 after、before 来实现，但是，垂直居中真的那么简单嘛？</p>
<p><strong>无特殊说明，本文示例都在小程序运行环境中</strong></p>
<p>我们来看个需求：</p>
<p></p>
<br></div><a href="/blog/2020/07/02/深挖-css-垂直居中的实现/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2019/09/18/你需要更简洁的-Redux（二）/" class="post-title-link">你需要更简洁的 Redux（二）</a></h2><div class="post-info">2019年9月18日</div><div class="post-content"><h2 id="上期回顾"><a href="#上期回顾" class="headerlink" title="上期回顾"></a>上期回顾</h2><p>首先我们先来回顾一下上一篇文章我们总结的几个痛点：</p>
<ul>
<li><p>低入侵</p>
</li>
<li><p>异步 Action</p>
</li>
<li><p>跨组件获取 Store</p>
<br></li></ul></div><a href="/blog/2019/09/18/你需要更简洁的-Redux（二）/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2019/09/13/你需要更简洁的-Redux（一）/" class="post-title-link">你需要更简洁的 Redux（一）</a></h2><div class="post-info">2019年9月13日</div><div class="post-content"><p>使用 React 的过程中，或多或少都会接触到 <strong>状态管理</strong> ，从 Flux 到 Redux 到 Dva，各种状态管理工具满天飞，今天让我们来聊一聊这些工具，以及思考在这些工具的基础上如何更简洁的使用 <strong>状态管理</strong> 这个大杀器。</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>聊状态管理之前，先让我们梳理下在原生 React 中如何进行组件间通信。</p>
<ul>
<li><p>Props</p>
<p>子组件需要父组件的数据，通过 props 一层层向下传递。</p>
<p>子组件需要更改父组件数据，通过 props callback 调用父组件的方法更新数据。</p>
<p>多个组件共享数据，抽象 Container 组件，从 Container 组件统一分发 props。</p>
<br></li></ul></div><a href="/blog/2019/09/13/你需要更简洁的-Redux（一）/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2018/01/16/30行代码的Google镜像站/" class="post-title-link">30行代码的Google镜像站</a></h2><div class="post-info">2018年1月16日</div><div class="post-content"><h4 id="DEMO-SO-FREEDOM"><a href="#DEMO-SO-FREEDOM" class="headerlink" title="DEMO: SO FREEDOM"></a><strong>DEMO: <a href="http://so.luoyefe.com/" target="_blank" rel="noopener">SO FREEDOM</a></strong></h4><h4 id="源码地址-https-github-com-luoye-fe-so"><a href="#源码地址-https-github-com-luoye-fe-so" class="headerlink" title="源码地址: https://github.com/luoye-fe/so/"></a><strong>源码地址: <a href="https://github.com/luoye-fe/so/" target="_blank" rel="noopener">https://github.com/luoye-fe/so/</a></strong></h4><p>又是一个充满噱头的标题 = =。</p>
<p>思路是在研究 <code>NodeJS</code> 代理时想到的小 trick，说是 30 行，其实最重要的只有一行，即：</p>
<pre><code class="line-numbers language-js">req.pipe(request(URL)).res;
</code></pre>
<p>将客户端来的请求直接转发到相应的 URL 上，实现代理，基于这个原理，可以很容易的实现各种网站的镜像站点。</p>
<p>服务端代码加注释如下：</p>
<pre><code class="line-numbers language-js">const fs = require(&#39;fs&#39;);
<br></code></pre></div><a href="/blog/2018/01/16/30行代码的Google镜像站/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2018/01/03/使用NodeJS借助阿里云dns解析API实现DDNS/" class="post-title-link">使用NodeJS借助阿里云dns解析API实现DDNS</a></h2><div class="post-info">2018年1月3日</div><div class="post-content"><p>DDNS，即动态DNS，简单来说就是服务器的 IP 地址经常变动，这个时候需要一个主动上报的服务来更新 DNS 的解析记录，保证域名指向正确的 IP 地址。  </p>
<p>比如在自己家中的树莓派上部署了某些服务，且路由器有公网 IP，由于每次重新拨号，公网 IP 都会变，所以想要根据域名去访问树莓派，必须做 DDNS。</p>
<p>DDNS 可以选择 花生壳，但是花生壳提供的 DDNS 服务无法自定义域名，配置起来也较为麻烦，所以这里用 NodeJS 来实现一个 DDNS 服务。</p>
<p><a href="https://github.com/luoye-fe/aliyun-ddns" target="_blank" rel="noopener">源码地址(https://github.com/luoye-fe/aliyun-ddns)</a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>定期获取本机公网 IP</p>
</li>
<br></ul></div><a href="/blog/2018/01/03/使用NodeJS借助阿里云dns解析API实现DDNS/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2017/11/13/借助redis实现定时任务/" class="post-title-link">借助redis实现定时任务</a></h2><div class="post-info">2017年11月13日</div><div class="post-content"><p>在 nodejs 中实现定时任务可以使用 <a href="https://github.com/node-schedule/node-schedule" target="_blank" rel="noopener">node-schedule</a> ，但是无法持久化，脚本停止后，不仅任务停止，再次启动也无法恢复未完成的定时任务。</p>
<p>当然也可以使用 crontab 这种方案，但是较为麻烦，其实可以简单的使用 redis 的 pub/sub 功能实现定时任务。</p>
<p>pub/sub 功能简单来说就是，当某个事件被触发时 redis 会向监听此事件的频道推送消息，所以，如果我们监听 redis 中某个 key 的过期事件，即可完成定时任务功能。</p>
<h2 id="redis-配置"><a href="#redis-配置" class="headerlink" title="redis 配置"></a>redis 配置</h2><p>redis 默认未启用 pub/sub 功能，需手动开启。</p>
<p>配置 <code>redis.conf</code> 的 <code>notify-keyspace-events</code> 字段来开启此功能，其值可以为以下值：</p>
<ul>
<li><p><strong>K</strong>，表示 <code>keyspace</code> 事件，有这个字母表示会往 <code>__keyspace@[db]__:[event]</code> 频道推消息</p>
<br></li></ul></div><a href="/blog/2017/11/13/借助redis实现定时任务/" class="read-more">...阅读全文</a></article></li></ul></section><footer><div class="paginator"><a href="/blog/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://luoyefe.com/blog">Luoye</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-78104533-1",'auto');ga('send','pageview');
var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?213cc17b8240ff47d16b1b3aa9dbe0ad";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="/blog/js/prism.js"></script></body></html>
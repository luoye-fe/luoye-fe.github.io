<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LUOYE</title><meta name="description" content="luoye, blog, coder"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/blog/favicon.ico"><link rel="stylesheet" href="/blog/css/apollo.css"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="https://luoyefe.com" target="_blank" class="nav-list-link">INDEX</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/luo-ye-42-22" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="https://github.com/luoye-fe" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://ss.luoyefe.com" target="_blank" class="nav-list-link">SHADOWSOCKS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2018/01/03/使用NodeJS借助阿里云dns解析API实现DDNS/" class="post-title-link">使用NodeJS借助阿里云dns解析API实现DDNS</a></h2><div class="post-info">2018年1月3日</div><div class="post-content"><p>DDNS，即动态DNS，简单来说就是服务器的 IP 地址经常变动，这个时候需要一个主动上报的服务来更新 DNS 的解析记录，保证域名指向正确的 IP 地址。  </p>
<p>比如在自己家中的树莓派上部署了某些服务，且路由器有公网 IP，由于每次重新拨号，公网 IP 都会变，所以想要根据域名去访问树莓派，必须做 DDNS。</p>
<p>DDNS 可以选择 花生壳，但是花生壳提供的 DDNS 服务无法自定义域名，配置起来也较为麻烦，所以这里用 NodeJS 来实现一个 DDNS 服务。</p>
<p><a href="https://github.com/luoye-fe/aliyun-ddns" target="_blank" rel="external">源码地址(https://github.com/luoye-fe/aliyun-ddns)</a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>定期获取本机公网 IP</p>
</li>
<br></div><a href="/blog/2018/01/03/使用NodeJS借助阿里云dns解析API实现DDNS/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2017/11/13/借助redis实现定时任务/" class="post-title-link">借助redis实现定时任务</a></h2><div class="post-info">2017年11月13日</div><div class="post-content"><p>在 nodejs 中实现定时任务可以使用 <a href="https://github.com/node-schedule/node-schedule" target="_blank" rel="external">node-schedule</a> ，但是无法持久化，脚本停止后，不仅任务停止，再次启动也无法恢复未完成的定时任务。</p>
<p>当然也可以使用 crontab 这种方案，但是较为麻烦，其实可以简单的使用 redis 的 pub/sub 功能实现定时任务。</p>
<p>pub/sub 功能简单来说就是，当某个事件被触发时 redis 会向监听此事件的频道推送消息，所以，如果我们监听 redis 中某个 key 的过期事件，即可完成定时任务功能。</p>
<h2 id="redis-配置"><a href="#redis-配置" class="headerlink" title="redis 配置"></a>redis 配置</h2><p>redis 默认未启用 pub/sub 功能，需手动开启。</p>
<p>配置 <code>redis.conf</code> 的 <code>notify-keyspace-events</code> 字段来开启此功能，其值可以为以下值：</p>
<ul>
<li><p><strong>K</strong>，表示 <code>keyspace</code> 事件，有这个字母表示会往 <code>__keyspace@[db]__:[event]</code> 频道推消息</p>
<br></div><a href="/blog/2017/11/13/借助redis实现定时任务/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2017/10/25/ss-ssl-复用端口/" class="post-title-link">shadowsocks/ssl 复用端口</a></h2><div class="post-info">2017年10月25日</div><div class="post-content"><p>前提：默认对对 nginx/shadowsocks(后面称 ss) 比较熟</p>
<p>目的：实现 https/ss 共用 443 端口</p>
<p>原因：公知原因 ss 已经会被检测到并封锁，特别是用非常见端口(80/443)，443 ssl 的默认端口来做 ss 服务更加稳定</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实很简单，ss 的原理在这不具体讲了，其实作用就相当于代理，把我们的请求通过 ss 这一层从目标服务器拿到数据再给我们。</p>
<p>既然要实现同一个端口访问不同的服务，就是在这两个服务前加一层代理，这层代理可以把 ss 流量转到 ss 的服务，把 web 的流量转到本地的 htps 端口。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>nginx + shadowsocksR</p>
<p><a href="https://github.com/shadowsocksr-backup/shadowsocksr" target="_blank" rel="external">shadowsocksR</a> 是在 ss 基础上的另一个实现，主要加上了更安全的加密措施等功能，其中对我们今天最重要的就是它的 <code>redirect</code> 功能。</p>
<br></div><a href="/blog/2017/10/25/ss-ssl-复用端口/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2017/06/07/nginx将多个服务代理到同一域名/" class="post-title-link">nginx将多个服务代理到同一域名</a></h2><div class="post-info">2017年6月7日</div><div class="post-content"><p>有时候需要将来自不同端口的服务代理到同一个域名上，利用 <code>nginx</code> 可以轻易实现这样的需求，记录如下。  </p>
<p>需求如下，两个 <code>node</code> 服务分别启动在 <code>8888</code> 和 <code>9999</code> 端口，然后在访问时需要将 <code>api.com/version1</code> 代理到 <code>127.0.0.1:8888</code>，将 <code>api.com/version2</code> 代理到 <code>127.0.0.1:9999</code>。  </p>
<p>利用 <code>nginx</code> 的 <code>location</code>，搭配 <code>proxy_pass</code> 来实现此功能的伪代码如下。  </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> api.com;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> /root/www;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~</span> /version1/ &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://127.0.0.1:8888/;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~</span> /version2/ &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://127.0.0.1:9999/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，访问 <code>api.com/version1/getUserInfo</code> 将访问到 <code>127.0.0.1:8888/getUserInfo</code>，同理，访问 <code>api.com/version2/getUserInfo</code> 将访问到 <code>127.0.0.1:9999/getUserInfo</code>。  </p>
<p><strong>注意</strong>：<code>proxy_pass</code> 最后的 <code>/</code> 不能丢，否则，<code>api.com/version1/getUserInfo</code> 将访问到 <code>127.0.0.1:8888/version1/getUserInfo</code>。  </p>
<p><code>location</code> 的匹配规则与优先级的详细可以访问，<a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/?from=https%3A%2F%2Fluoyefe.com" target="_blank" rel="external">nginx配置location总结及rewrite规则写法</a>。</p>
<br></div><a href="/blog/2017/06/07/nginx将多个服务代理到同一域名/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2017/01/23/豆瓣阅读的文字解码/" class="post-title-link">豆瓣阅读的文字解码</a></h2><div class="post-info">2017年1月23日</div><div class="post-content"><p>前段时间找本小说发现只有豆瓣有资源，然而并不能下载，就想着把全本爬下来，现将接口和解码相关记录如下。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>URL: <a href="https://read.douban.com/j/article_v2/get_reader_data" target="_blank" rel="external">https://read.douban.com/j/article_v2/get_reader_data</a></p>
</li>
<li><p>Method: <code>POST</code></p>
</li>
<li><p>Body: </p>
<br></div><a href="/blog/2017/01/23/豆瓣阅读的文字解码/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2016/12/02/write-a-nodejs-proxy-support-http-https/" class="post-title-link">write-a-nodejs-proxy-support-http/https</a></h2><div class="post-info">2016年12月2日</div><div class="post-content"><p>web 开发的调试过程不可避免的涉及到代理的问题，当然现在很多工具都可以完成这项工作，比如 Win 下的 <code>Fiddler</code>，Mac 下的 <code>Charles</code>，今天我们来看一下怎么用 <code>NodeJS</code> 完成这些代理工作，当然，必须支持 <code>http/https</code> 两种常见协议。  </p>
<h3 id="代理原理"><a href="#代理原理" class="headerlink" title="代理原理"></a>代理原理</h3><p>要想实现代理的目的，就得有一个代理服务的存在，客户端的请求不会直接到达服务器，而是先经过代理服务，然后由代理服务来处理这个请求，不管是原样的转发到目标服务器，还是拦截下来做自定义的回复。</p>
<p>下图来自《HTTP权威指南》，直观的展示了一个代理服务所做的工作：</p>
<p>  </p>
<p>实现这个客户端请求转发到代理服务的工具当然可以用系统的代理配置，不过推荐使用 <code>Chrome</code> 的一个插件 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">Proxy SwitchyOmega</a>.  </p>
<h3 id="创建-HTTP-代理服务"><a href="#创建-HTTP-代理服务" class="headerlink" title="创建 HTTP 代理服务"></a>创建 HTTP 代理服务</h3><p>了解了代理的原理之后，我们来实现一个简单的代理服务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">http.createServer()  </span><br><span class="line">    .on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 解析请求参数</span></span><br><span class="line">        <span class="keyword">const</span> urlObj = url.parse(req.url);</span><br><span class="line">        <span class="keyword">const</span> options = &#123;</span><br><span class="line">            hostname: urlObj.hostname,  </span><br><span class="line">            port: urlObj.port || <span class="number">80</span>,</span><br><span class="line">            path: urlObj.path,</span><br><span class="line">            method: req.method,</span><br><span class="line">            headers: req.headers</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 新建一个请求到真实服务器</span></span><br><span class="line">        <span class="keyword">const</span> pReq = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">curRes</span>) </span>&#123;</span><br><span class="line">            res.writeHead(curRes.statusCode, curRes.headers);</span><br><span class="line">            <span class="comment">// 返回给浏览器</span></span><br><span class="line">            curRes.pipe(res);</span><br><span class="line">        &#125;).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            res.end();</span><br><span class="line">        &#125;);</span><br><span class="line">        req.pipe(pReq);</span><br><span class="line">    &#125;)</span><br><span class="line">    .listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<br></div><a href="/blog/2016/12/02/write-a-nodejs-proxy-support-http-https/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2016/07/21/git相关/" class="post-title-link">git相关</a></h2><div class="post-info">2016年7月21日</div><div class="post-content"><h2 id="git-开始"><a href="#git-开始" class="headerlink" title="git 开始"></a>git 开始</h2><ul>
<li><p><a href="https://git-scm.com/" target="_blank" rel="external">git 下载</a></p>
</li>
<li><p><a href="https://git-for-windows.github.io/" target="_blank" rel="external">git for windows</a></p>
</li>
</ul>
<h2 id="git-文章推荐"><a href="#git-文章推荐" class="headerlink" title="git 文章推荐"></a>git 文章推荐</h2><ul>
<br></div><a href="/blog/2016/07/21/git相关/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2016/07/13/客服平台总结/" class="post-title-link">客服平台总结</a></h2><div class="post-info">2016年7月13日</div><div class="post-content"><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue是一个构建数据驱动的 web 界面的库，也就是一个以 MVVM 为核心的库。  </p>
<h4 id="为什么选择Vue"><a href="#为什么选择Vue" class="headerlink" title="为什么选择Vue"></a>为什么选择Vue</h4><ul>
<li><p>简洁</p>
<p>  API 足够简洁明了，文档足够清晰有条理，上手难度足够低</p>
<p>  HTML 模板加上 JSON 数据，就是一个 Vue 实例。    </p>
</li>
<li><p>数据驱动</p>
<br></div><a href="/blog/2016/07/13/客服平台总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2016/06/23/我的sublime配置/" class="post-title-link">我的sublime配置</a></h2><div class="post-info">2016年6月23日</div><div class="post-content"><h2 id="功能插件"><a href="#功能插件" class="headerlink" title="功能插件"></a>功能插件</h2><ul>
<li><p>Emmet</p>
<p>  写 <code>html</code> 的利器，不用多说</p>
</li>
<li><p>Babel  </p>
<p>  不仅能够识别更多的js方言，让sublime有正确的着色，而且能够支持ES6的语法提示等</p>
</li>
<br></div><a href="/blog/2016/06/23/我的sublime配置/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/2016/06/09/js中的异步流程控制-Promise-Generators-Async-Await/" class="post-title-link">js中的异步流程控制--Promise/Generator/Async/Await</a></h2><div class="post-info">2016年6月9日</div><div class="post-content"><blockquote>
<p>长文预警 ～</p>
</blockquote>
<p>异步I/O、事件驱动使JS这个单线程语言在不阻塞的情况下可以并行的执行很多任务，这带来了性能的极大提升，并且更加符合人们的自然认识（烧一壶水，期间你肯定不会等着水烧开再去做别的事，异步才是正常的啊！）。然而异步风格也给流程控制，错误处理带来了更多的麻烦。</p>
<h3 id="一、回调"><a href="#一、回调" class="headerlink" title="一、回调"></a>一、回调</h3><p>回调是JS的基础，函数可以作为参数传递并在恰当的时机执行，比如有下面的三个函数：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure>
<p>如果 <code>f1</code> 中存在异步操作，比如 <code>ajax</code> 请求，并且 <code>f2</code> 需要在 <code>f1</code> 执行完毕之后执行，那么可以使用回调的方式改写函数，如下：  </p>
<br></div><a href="/blog/2016/06/09/js中的异步流程控制-Promise-Generators-Async-Await/" class="read-more">...阅读全文</a></article></li></ul></section><footer><div class="paginator"><a href="/blog/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://luoyefe.com/blog">Luoye</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-78104533-1",'auto');ga('send','pageview');
var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?213cc17b8240ff47d16b1b3aa9dbe0ad";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LUOYE</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://luoye.pw/blog/"/>
  <updated>2016-12-09T09:01:48.000Z</updated>
  <id>http://luoye.pw/blog/</id>
  
  <author>
    <name>Luoye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>write-a-nodejs-proxy-support-http/https</title>
    <link href="http://luoye.pw/blog/2016/12/02/write-a-nodejs-proxy-support-http-https/"/>
    <id>http://luoye.pw/blog/2016/12/02/write-a-nodejs-proxy-support-http-https/</id>
    <published>2016-12-02T10:33:41.000Z</published>
    <updated>2016-12-09T09:01:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>web 开发的调试过程不可避免的涉及到代理的问题，当然现在很多工具都可以完成这项工作，比如 Win 下的 <code>Fiddler</code>，Mac 下的 <code>Charles</code>，今天我们来看一下怎么用 <code>NodeJS</code> 完成这些代理工作，当然，必须支持 <code>http/https</code> 两种常见协议。  </p>
<h3 id="代理原理"><a href="#代理原理" class="headerlink" title="代理原理"></a>代理原理</h3><p>要想实现代理的目的，就得有一个代理服务的存在，客户端的请求不会直接到达服务器，而是先经过代理服务，然后由代理服务来处理这个请求，不管是原样的转发到目标服务器，还是拦截下来做自定义的回复。</p>
<p>下图来自《HTTP权威指南》，直观的展示了一个代理服务所做的工作：</p>
<p><img src="./web_proxy.png.webp" alt="proxy">  </p>
<p>实现这个客户端请求转发到代理服务的工具当然可以用系统的代理配置，不过推荐使用 <code>Chrome</code> 的一个插件 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">Proxy SwitchyOmega</a>.  </p>
<h3 id="创建-HTTP-代理服务"><a href="#创建-HTTP-代理服务" class="headerlink" title="创建 HTTP 代理服务"></a>创建 HTTP 代理服务</h3><p>了解了代理的原理之后，我们来实现一个简单的代理服务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line">http.createServer()  </div><div class="line">    .on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</div><div class="line">        <span class="comment">// 解析请求参数</span></div><div class="line">        <span class="keyword">const</span> urlObj = url.parse(req.url);</div><div class="line">        <span class="keyword">const</span> options = &#123;</div><div class="line">            <span class="attr">hostname</span>: urlObj.hostname,  </div><div class="line">            <span class="attr">port</span>: urlObj.port || <span class="number">80</span>,</div><div class="line">            <span class="attr">path</span>: urlObj.path,</div><div class="line">            <span class="attr">method</span>: req.method,</div><div class="line">            <span class="attr">headers</span>: req.headers</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 新建一个请求到真实服务器</span></div><div class="line">        <span class="keyword">const</span> pReq = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">curRes</span>) </span>&#123;</div><div class="line">            res.writeHead(curRes.statusCode, curRes.headers);</div><div class="line">            <span class="comment">// 返回给浏览器</span></div><div class="line">            curRes.pipe(res);</div><div class="line">        &#125;).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            res.end();</div><div class="line">        &#125;);</div><div class="line">        req.pipe(pReq);</div><div class="line">    &#125;)</div><div class="line">    .listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p>上述代码会在本地的 <code>8080</code> 端口创建 HTTP 服务，如果配置浏览器的代理为 <code>127.0.0.1:8080</code>，这个服务就能接收到浏览器发出的 HTTP 请求，并且从请求中解析相应的参数，新建一个到真实服务器的请求，得到真实服务器响应后，再返回给浏览器，完成一次代理。  </p>
<p>当然，如果你想对转发到本代理服务的请求做拦截并且自定义返回内容，只需要对 <code>res</code> 进行操作即可。  </p>
<p>但是，这个代理服务正常运行之后你会发现，HTTPS 的请求无法在本代理服务中捕获，这是为什么呢？  </p>
<p>因为我们现在创建的服务是一个 HTTP 服务，无法处理 HTTPS 请求，那是不是创建一个 HTTPS 的服务就可以了呢？  </p>
<p>答案是肯定的，如果想要代理并且处理浏览器发出的 HTTPS 请求，我们就必须再创建一个 HTTPS 服务。  </p>
<p>创建 HTTPS 服务很简单，重要的是，如何让 HTTPS 请求到达我们的服务器，重新设置浏览器的代理么？并不用这么麻烦。  </p>
<h3 id="转发-HTTPS-请求"><a href="#转发-HTTPS-请求" class="headerlink" title="转发 HTTPS 请求"></a>转发 HTTPS 请求</h3><p>不管是 HTTP 还是 HTTPS ，都是一种网络应用协议，它最本质的还是一次 TCP 连接，而 TCP 连接我们可以用 CONNECT 方法捕获到，所以有了以下代码：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line">http.createServer()</div><div class="line">    .on(<span class="string">'connect'</span>, (req, socket, upgradeHead) =&gt; &#123;</div><div class="line">        <span class="comment">// 利用 `NodeJS` 的 `net` 模块的 `Socket`，处理 CONNECT 请求</span></div><div class="line">        <span class="keyword">const</span> socketClient = <span class="keyword">new</span> net.Socket();</div><div class="line">        <span class="keyword">const</span> urlObj = url.parse(<span class="string">'https://'</span> + req.url); <span class="comment">// CONNECT 只能拿到请求的域名和端口，拼接下再解析</span></div><div class="line"></div><div class="line">        <span class="keyword">let</span> realport = urlObj.port || <span class="number">443</span>;</div><div class="line">        <span class="keyword">let</span> realDomain = urlObj.hostname;</div><div class="line">        </div><div class="line">        <span class="comment">// 转发到真实服务器</span></div><div class="line">        socketClient.connect(realport, realDomain, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            socket.write(<span class="string">"HTTP/"</span> + req.httpVersion + <span class="string">" 200 Connection established\r\n\r\n"</span>);</div><div class="line">        &#125;);</div><div class="line">        socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">            socketClient.write(chunk);</div><div class="line">        &#125;);</div><div class="line">        socket.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            socketClient.end();</div><div class="line">        &#125;);</div><div class="line">        socket.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            socketClient.end();</div><div class="line">        &#125;);</div><div class="line">        socket.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">            socketClient.end();</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 返回给浏览器</span></div><div class="line">        socketClient.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">            socket.write(chunk);</div><div class="line">        &#125;);</div><div class="line">        socketClient.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            socket.end();</div><div class="line">        &#125;);</div><div class="line">        socketClient.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            socket.end();</div><div class="line">        &#125;);</div><div class="line">        socketClient.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">            socket.end();</div><div class="line">        &#125;);</div><div class="line">    &#125;)</div><div class="line">    .listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p>上述代码将会在本地的 8080 端口启动一个 HTTP 服务，并且监听 CONNECT 事件并做原样转发，在这个代理服务中我们可以捕获到浏览器的 HTTPS 请求，并且通过我们的代理服务进行向真实服务器的转发工作。  </p>
<p>既然我们已经可以捕获到 HTTPS 请求，那完成对 HTTPS 请求的处理中之后我们就可以得到一个完整的 web 代理服务。  </p>
<h3 id="创建-HTTPS-服务"><a href="#创建-HTTPS-服务" class="headerlink" title="创建 HTTPS 服务"></a>创建 HTTPS 服务</h3><p>HTTPS 服务的创建 <code>NodeJS</code> 为我们提供了 <code>https</code> 模块，但是想要创建 HTTPS 服务，必须有 HTTPS 证书才行，HTTPS 证书的颁发国际上有很多机构。作为个人开发者我们可以借助 <code>openssl</code> 工具创建自签署的证书。  </p>
<p>具体请谷歌～  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -des3 -out private.key 2048 <span class="comment"># 生成私钥</span></div><div class="line">openssl req -new -key private.key -out server.csr <span class="comment"># 根据开发者提供的信息生成中间文件</span></div><div class="line">openssl x509 -req -in server.csr -out server.crt -outform pem -signkey server.key -days 3650 <span class="comment"># 根据中间文件生成证书和公钥</span></div></pre></td></tr></table></figure>
<p>有个相应的证书之后我们就可以借此创建 HTTPS 服务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</div><div class="line">https.createServer(&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">'./server.key'</span>,</div><div class="line">    <span class="attr">cert</span>: <span class="string">'./server.crt'</span></div><div class="line">&#125;).listen(<span class="number">9090</span>)</div></pre></td></tr></table></figure>
<p>上述代码将会在本地的 9090 端口启动 HTTPS 服务。  </p>
<h3 id="整合代理服务"><a href="#整合代理服务" class="headerlink" title="整合代理服务"></a>整合代理服务</h3><p>能够捕获浏览的 HTTP/HTTPS 请求，也有了 HTTP/HTTPS 服务，我们就可以完整的完成一个代理服务，全部代码如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</div><div class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> httpServer = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> httpsServer = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> httpPort = <span class="number">8080</span>;</div><div class="line"><span class="keyword">let</span> httpsPort = <span class="number">9090</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> needProxy = <span class="literal">true</span>; <span class="comment">// 可以定义代理规则等</span></div><div class="line"></div><div class="line">httpServer = http.createServer().listen(httpPort);</div><div class="line">httpsServer = https.createServer(&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">'./server.key'</span>,</div><div class="line">    <span class="attr">cert</span>: <span class="string">'./server.crt'</span></div><div class="line">&#125;).listen(httpsPort);</div><div class="line"></div><div class="line">httpServer.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</div><div class="line">    <span class="comment">// 处理 http 请求</span></div><div class="line">    <span class="keyword">if</span> (needProxy) &#123;</div><div class="line">        <span class="comment">// 自定义返回内容</span></div><div class="line">        res.write(<span class="string">'Proxy server is running.'</span>)</div><div class="line">        res.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 原样返回</span></div><div class="line">        <span class="keyword">const</span> urlObj = url.parse(req.url);</div><div class="line">        <span class="keyword">const</span> options = &#123;</div><div class="line">            <span class="attr">hostname</span>: urlObj.hostname,  </div><div class="line">            <span class="attr">port</span>: urlObj.port || <span class="number">80</span>,</div><div class="line">            <span class="attr">path</span>: urlObj.path,</div><div class="line">            <span class="attr">method</span>: req.method,</div><div class="line">            <span class="attr">headers</span>: req.headers</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 新建一个请求到真实服务器</span></div><div class="line">        <span class="keyword">const</span> pReq = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">curRes</span>) </span>&#123;</div><div class="line">            res.writeHead(curRes.statusCode, curRes.headers);</div><div class="line">            curRes.pipe(res);</div><div class="line">        &#125;).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">            res.end();</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// 返回给浏览器</span></div><div class="line">        req.pipe(pReq);</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">httpsServer.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</div><div class="line">    <span class="comment">// 接受到 CONNECT 转发来的 HTTPS 请求，并自定义返回内容</span></div><div class="line">    res.write(<span class="string">'Proxy server is running.'</span>)</div><div class="line">    res.end();</div><div class="line">&#125;)</div><div class="line"></div><div class="line">httpServer.on(<span class="string">'connect'</span>, (req, socket, upgradeHead) =&gt; &#123;</div><div class="line">    <span class="comment">// 利用 `NodeJS` 的 `net` 模块的 `Socket`，处理 CONNECT 请求</span></div><div class="line">    <span class="keyword">const</span> socketClient = <span class="keyword">new</span> net.Socket();</div><div class="line">    <span class="keyword">const</span> urlObj = url.parse(<span class="string">'https://'</span> + req.url); <span class="comment">// CONNECT 只能拿到请求的域名和端口，拼接下再解析</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> realport = urlObj.port || <span class="number">443</span>;</div><div class="line">    <span class="keyword">let</span> realDomain = urlObj.hostname;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (needProxy) &#123;</div><div class="line">        <span class="comment">// 转发到本地 HTTPS 服务</span></div><div class="line">        socketClient.connect(<span class="string">'127.0.0.1'</span>, httpsPort, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            socket.write(<span class="string">"HTTP/"</span> + req.httpVersion + <span class="string">" 200 Connection established\r\n\r\n"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 转发到真实服务器</span></div><div class="line">        socketClient.connect(realport, realDomain, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            socket.write(<span class="string">"HTTP/"</span> + req.httpVersion + <span class="string">" 200 Connection established\r\n\r\n"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">        socketClient.write(chunk);</div><div class="line">    &#125;);</div><div class="line">    socket.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        socketClient.end();</div><div class="line">    &#125;);</div><div class="line">    socket.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        socketClient.end();</div><div class="line">    &#125;);</div><div class="line">    socket.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">        socketClient.end();</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// 返回给浏览器</span></div><div class="line">    socketClient.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">        socket.write(chunk);</div><div class="line">    &#125;);</div><div class="line">    socketClient.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        socket.end();</div><div class="line">    &#125;);</div><div class="line">    socketClient.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        socket.end();</div><div class="line">    &#125;);</div><div class="line">    socketClient.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">        socket.end();</div><div class="line">    &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不到 100 行代码，一个简单的 proxy 服务器已经搭建完成，支持 HTTP/HTTPS 代理，在这个基础上，完全可以进行再开发，比如代理规则的扩充，查看浏览器请求流，具体应用等。  </p>
<p>本文就写到这里，欢迎评论留言。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web 开发的调试过程不可避免的涉及到代理的问题，当然现在很多工具都可以完成这项工作，比如 Win 下的 &lt;code&gt;Fiddler&lt;/code&gt;，Mac 下的 &lt;code&gt;Charles&lt;/code&gt;，今天我们来看一下怎么用 &lt;code&gt;NodeJS&lt;/code&gt; 完成这
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git相关</title>
    <link href="http://luoye.pw/blog/2016/07/21/git%E7%9B%B8%E5%85%B3/"/>
    <id>http://luoye.pw/blog/2016/07/21/git相关/</id>
    <published>2016-07-21T13:54:30.000Z</published>
    <updated>2016-12-02T11:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-开始"><a href="#git-开始" class="headerlink" title="git 开始"></a>git 开始</h2><ul>
<li><p><a href="https://git-scm.com/" target="_blank" rel="external">git 下载</a></p>
</li>
<li><p><a href="https://git-for-windows.github.io/" target="_blank" rel="external">git for windows</a></p>
</li>
</ul>
<h2 id="git-文章推荐"><a href="#git-文章推荐" class="headerlink" title="git 文章推荐"></a>git 文章推荐</h2><ul>
<li><p><a href="http://www.runoob.com/manual/git-guide/" target="_blank" rel="external">git 简明指南</a></p>
</li>
<li><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰-Git教程</a></p>
</li>
<li><p><a href="https://git-scm.com/docs" target="_blank" rel="external">git 官方文档 - 所有命令</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/fanfan259/p/4810517.html" target="_blank" rel="external">git 常用命令收集</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/104fa8b15d1e" target="_blank" rel="external">git flow 讲解</a></p>
</li>
<li><p><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">git flow 模型原文</a></p>
<blockquote>
<p>git flow 将是我们遵循的开发流程。当然，会根据具体业务做相应调整，但是原理不变</p>
</blockquote>
</li>
<li><p><a href="http://www.cnblogs.com/fanyong/p/3962455.html" target="_blank" rel="external">gitlab/github多账户管理ssh</a></p>
<blockquote>
<p>ssh 简单来说就是一种加密通信手段，服务器保存一段密文，你本地保存一段密文，互相通信就不再需要帐号密码</p>
<p>所以，在 git 中提交代码时，如果不想每次输入帐号密码，可以用 ssh 达到验证账户的目的</p>
</blockquote>
</li>
</ul>
<h2 id="git-图形化工具推荐"><a href="#git-图形化工具推荐" class="headerlink" title="git 图形化工具推荐"></a>git 图形化工具推荐</h2><blockquote>
<p>除了使用 git bash 用命令行的方式进行 git 操作，同样有很棒的图形化工具提高工作效率</p>
</blockquote>
<ul>
<li><p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Source Tree</a>（需翻墙下载）</p>
<blockquote>
<p>前端群里有分享文件 1.8.3 版本</p>
</blockquote>
</li>
</ul>
<h2 id="git-其他"><a href="#git-其他" class="headerlink" title="git 其他"></a>git 其他</h2><ul>
<li><p><a href="http://learngitbranching.js.org/?demo" target="_blank" rel="external">git 动画演示</a></p>
</li>
<li><p><a href="http://onlywei.github.io/explain-git-with-d3/" target="_blank" rel="external">git 操作实时动画</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/wicub/p/3646070.html" target="_blank" rel="external">githug</a>（git 小游戏）</p>
</li>
<li><p><a href="http://www.jianshu.com/p/482b32716bbe" target="_blank" rel="external">github 通关攻略</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git-开始&quot;&gt;&lt;a href=&quot;#git-开始&quot; class=&quot;headerlink&quot; title=&quot;git 开始&quot;&gt;&lt;/a&gt;git 开始&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>客服平台总结</title>
    <link href="http://luoye.pw/blog/2016/07/13/%E5%AE%A2%E6%9C%8D%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://luoye.pw/blog/2016/07/13/客服平台总结/</id>
    <published>2016-07-13T03:19:42.000Z</published>
    <updated>2016-07-14T08:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue是一个构建数据驱动的 web 界面的库，也就是一个以 MVVM 为核心的库。  </p>
<h4 id="为什么选择Vue"><a href="#为什么选择Vue" class="headerlink" title="为什么选择Vue"></a>为什么选择Vue</h4><ul>
<li><p>简洁</p>
<p>  API 足够简洁明了，文档足够清晰有条理，上手难度足够低</p>
<p>  HTML 模板加上 JSON 数据，就是一个 Vue 实例。    </p>
</li>
<li><p>数据驱动</p>
<p>  DOM和数据绑定，对数据的操作自动追踪依赖的模板表达式，自动更新DOM。  </p>
<p>  例如，列表的渲染，只需给定一个数组，将这个数组绑定到列表的模板表达式上，数组的变化自动触发DOM的更新，无需手动维护DOM。  </p>
</li>
<li><p>组件化</p>
<p>  提供了一套完整的组件化开发方式，用解藕、可敷用的组件来构造界面，极大简化代码量的同时，对维护工作也相当友好。  </p>
<p>  例如，全局的 loading/alert/表单 组件、局部的表格组件，一处定义，多处复用，一处更改，全局同步。  </p>
</li>
<li><p>快速</p>
<p>  库内部对自动更新DOM的操作做了很多优化，内部ID排序，最小变更步骤等，和手动更新DOM相比，速度更快。  </p>
</li>
<li><p>轻量但不失强大</p>
<p>  Vue 本身只是一个关注 view 层的轻量化库，但是搭配官方出品的几个轻量库，能够完成相当复杂的 web 应用。  </p>
<p>  例如，客服平台中用到的 vue-router ，用来控制路由；vuex，用来集中式管理应用状态，控制 SPA 内数据流向。  </p>
</li>
<li><p>新技术的试验田</p>
<p>  Vue 足够灵活，能够完美的搭配前端中新兴的各种技术，加快开发效率，规范开发流程，减少人工操纵。  </p>
<p>  例如，客服平台中模块化的 js 开发方式，webpack 编译，NPM 管理依赖，sass 书写样式等，都能够融合进 vue 的开发体系中。  </p>
</li>
</ul>
<h4 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h4><ul>
<li><p><a href="http://cn.vuejs.org/" target="_blank" rel="external">Vue 文档</a></p>
</li>
<li><p><a href="http://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">Vue-router 文档</a></p>
</li>
<li><p><a href="http://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="external">Vuex 文档</a></p>
</li>
</ul>
<h2 id="NodeJs-Npm"><a href="#NodeJs-Npm" class="headerlink" title="NodeJs/Npm"></a>NodeJs/Npm</h2><h4 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h4><p>NodeJs 虽然是一门后端语言，但是在前端工作中，利用 NodeJs 开发的一些工具能够极大简化我们的工作。  </p>
<p>例如，客服平台实现了一个简易的 web server，本地开发时以这个 web server 作为入口，可以很方便的访问接口，代理静态资源等。  </p>
<p>利用 NodeJs 开发的工具也能够完成自动化操作、构建等任务，这个将在下文的 webpack/gulp 部分具体讲述。</p>
<h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><p>NPM 是管理 NodeJs 开发依赖的工具，同样能够用在前端的开发工作中，大部分的开发依赖通过 NPM 来管理，杜绝手工管理依赖包，也能够很方便的控制依赖的版本。  </p>
<p>NPM 还提供一些便捷的 script 定义方式，在一个 NPM 项目下，会存在一个 <code>package.json</code> 文件，其中有一个字段为 <code>scripts</code> ，在这个字段中定义的 key ，可以通过 <code>npm run {key}</code> 来执行 value 中的命令。  </p>
<p>例如，在本地开发时，需要连接后台人员的机器，可以执行 <code>npm run localtest</code> 命令，而实际执行的命令是 <code>scripts</code> 字段中 <code>localtest</code> 对应的 <code>NODE_ENV=localtest gulp watch</code> 命令。  </p>
<p>这相当于为某些命令做了个缩写，但是在本项目中，由于环境变量定义方式不同，mac 环境可以直接执行 <code>npm run localtest</code> ，win 上只能执行具体的命令 <code>NODE_ENV=localtest gulp watch</code>。  </p>
<h4 id="相关文档-1"><a href="#相关文档-1" class="headerlink" title="相关文档"></a>相关文档</h4><ul>
<li><p><a href="http://nodejs.cn/api/" target="_blank" rel="external">NodeJs 文档</a></p>
</li>
<li><p><a href="https://docs.npmjs.com/" target="_blank" rel="external">NPM 文档</a></p>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>客服平台对 NodeJs 的依赖不可或缺，开发人员必须安装 NodeJs ，建议版本 v4.2.4</p>
<h2 id="ES6-7"><a href="#ES6-7" class="headerlink" title="ES6/7"></a>ES6/7</h2><p>JavaScript 这门语言在以往的版本中存在着很多缺陷，比如没有类，没有标准的模块管理，没有统一的异步流程控制API，没有块级作用域赋值等等，但是在新版本中，这些都有了相应的解决方案，所以客服平台的开发，我们选择了 JS 的新标准 ES6 作为主要开发语言。  </p>
<p>本项目中用到的主要 ES6 新特性包括：  </p>
<ul>
<li>变量声明：let/const 命令</li>
<li>变量的结构赋值</li>
<li>模板字符串</li>
<li>箭头函数</li>
<li>模块管理：import/export</li>
<li>Promise 对象控制异步流程</li>
<li>其他的新API</li>
</ul>
<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6 文档</a></p>
<h2 id="Webpack-Gulp"><a href="#Webpack-Gulp" class="headerlink" title="Webpack/Gulp"></a>Webpack/Gulp</h2><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>上文提到，我们用了 Vue，用了 ES6，用了很多新特性新东西，但是对于浏览器来说，这些东西浏览器是没有办法直接运行的，所以需要有构建这一过程，我们选择了 webpack 这个工具。  </p>
<p>webpack 是一个灵活的模块打包工具，搭配不同的 plugin 和 loader 可以打包几乎所有 js 方言，css 方言，不同的模板文件，最后生成可供浏览器直接运行的 js 文件。  </p>
<p>客服平台的 webpack 配置在 <code>gulpfile.js</code> 文件的 <code>webpackConfig</code> 变量中，具体可以看代码。  </p>
<p><a href="http://webpack.github.io/docs/" target="_blank" rel="external">webpack 文档</a></p>
<h4 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h4><p>除了 webpack 用来打包构建之外，还有一些额外的自动化工作需要完成，比如图片的拷贝，静态资源更改 hash 值以控制缓存，打包四个环境不同的 bundle 包等，这一部分我们选择了 gulp 来完成。  </p>
<p>gulp 主要利用 NodeJs 文件流的概念在内存中操作文件，减少 IO 操作，能够更加快速的完成复杂的构建工作。  </p>
<p><a href="http://www.gulpjs.com.cn/docs/" target="_blank" rel="external">gulp 文档</a></p>
<h2 id="Sass-Jade"><a href="#Sass-Jade" class="headerlink" title="Sass/Jade"></a>Sass/Jade</h2><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>一个 css 方言，提供了嵌套的书写方式，css 的变量定义，逻辑控制功能等。  </p>
<p>客服平台使用的是页面构建组提供的 sass 源码，最后使用 gulp 编译成浏览器可识别的 css。  </p>
<p><a href="http://sass.bootcss.com/docs/sass-reference/" target="_blank" rel="external">sass 文档</a></p>
<h4 id="Jade-Pug"><a href="#Jade-Pug" class="headerlink" title="Jade(Pug)"></a>Jade(Pug)</h4><p>HTML 模板引擎，页面构建组使用的 HTML 方言，用更加简洁的方式书写 HTML，也可以在 HTML 中加以逻辑，写出更加强大健壮的 HTML 模板。  </p>
<p>客服平台使用的是页面构建组提供的生成后的普通 HTML 文件。  </p>
<p>已更名为 Pug 。  </p>
<p><a href="http://jade-lang.com/" target="_blank" rel="external">pug 文档</a></p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>客服平台的所有代码，都托管在公司的 gitlab 上，项目地址是： <code>http://gitlab.intra.gomeplus.com/gomeplusFED/CSP</code>。  </p>
<p>配合 git ，我们完成了一套完整的开发发布流程。  </p>
<h2 id="Webscoket"><a href="#Webscoket" class="headerlink" title="Webscoket"></a>Webscoket</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>WebSocket协议，代替原先http协议的1s轮询，能更好的节省服务器资源和带宽并达到实时通讯，本项目用于客服与买家的实时通讯聊天、表情、上传图片、接收图片音频视频。   </p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个Socket实例</span></div><div class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>); </div><div class="line"></div><div class="line"><span class="comment">// 打开Socket </span></div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </div><div class="line"></div><div class="line">    <span class="comment">// 发送一个初始化消息</span></div><div class="line">    socket.send(<span class="string">'I am the client and I\'m listening!'</span>); </div><div class="line"></div><div class="line">    <span class="comment">// 监听消息</span></div><div class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Client received a message'</span>,event); </div><div class="line">    &#125;; </div><div class="line"></div><div class="line">    <span class="comment">// 监听Socket的关闭</span></div><div class="line">    socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Client notified socket has closed'</span>,event); </div><div class="line">    &#125;;    </div><div class="line">   </div><div class="line">    <span class="comment">// 监听Socket报错</span></div><div class="line">    socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Client notified socket has error'</span>,event); </div><div class="line">    &#125;; </div><div class="line"></div><div class="line">    <span class="comment">// 关闭Socket.... </span></div><div class="line">    <span class="comment">//socket.close() </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h4 id="断开重连机制"><a href="#断开重连机制" class="headerlink" title="断开重连机制"></a>断开重连机制</h4><ul>
<li><p>断网重连</p>
</li>
<li><p>关闭重连</p>
</li>
<li><p>异常重连</p>
</li>
<li><p>客服选择在线重连    </p>
</li>
</ul>
<p><a href="https://msdn.microsoft.com/library/hh673567.aspx" target="_blank" rel="external">Webscoket 文档</a></p>
<h2 id="业务详解"><a href="#业务详解" class="headerlink" title="业务详解"></a>业务详解</h2><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">├── src                             源码文件夹</div><div class="line">│   ├── font                            font 文件夹</div><div class="line">│   ├── img                             img 文件夹</div><div class="line">│   ├── css                             css 文件夹</div><div class="line">│   │   ├── app.scss                        样式主入口</div><div class="line">│   │   ├── common                          基础样式文件夹</div><div class="line">│   │   ├── module                          业务样式文件夹</div><div class="line">│   │   │   └── all.scss                        所有业务样式</div><div class="line">│   │   └── vendors                         第三方插件样式</div><div class="line">│   └── js                              js 文件夹</div><div class="line">│       ├── app.js                          app 入口文件 （定义路由表，启动项目，过滤ajax请求等）</div><div class="line">│       ├── debug.js                        debug 文件 （定义一些全局变量，在控制台直接调用）</div><div class="line">│       ├── base                            基础功能文件夹</div><div class="line">│       ├── component                       组件文件夹</div><div class="line">│       │   ├── app.vue                         入口组件 （组织全局组件，定义路由容器）</div><div class="line">│       │   ├── base                            全局组件 （alert、loading组件等）</div><div class="line">│       │   ├── common                          通用组件 （导航、时间选择器、头部、尾部等）</div><div class="line">│       │   ├── dashboard                       dashboard 路由下所有组件</div><div class="line">│       │   │   ├── account-manage.vue              账户管理</div><div class="line">│       │   │   ├── chat-record.vue                 聊天记录</div><div class="line">│       │   │   ├── common-msg.vue                  常用语</div><div class="line">│       │   │   ├── config.vue                      配置管理</div><div class="line">│       │   │   ├── index.vue                       首页</div><div class="line">│       │   │   └── password.vue                    修改密码</div><div class="line">│       │   ├── form                            通用表单组件</div><div class="line">│       │   ├── im                              im 路由下所有组件</div><div class="line">│       │   │   ├── common_msg.vue                  常用语</div><div class="line">│       │   │   ├── contacts.vue                    联系人</div><div class="line">│       │   │   ├── header.vue                      头部 </div><div class="line">│       │   │   ├── index.vue                       首页</div><div class="line">│       │   │   └── record.vue                      聊天记录</div><div class="line">│       │   └── login                           登陆组件</div><div class="line">│       ├── config                              配置文件</div><div class="line">│       │   ├── env                                 环境设置</div><div class="line">│       │   └── http.json                           AJAX 请求跟路径配置文件</div><div class="line">│       ├── directive                           指令文件夹</div><div class="line">│       ├── filter                              过滤器文件夹</div><div class="line">│       ├── store                               vuex 文件夹</div><div class="line">│       ├── util                                工具函数文件夹</div><div class="line">│       └── vendors                             第三方插件文件夹</div><div class="line">├── dist                            编译打包生成的dist文件</div><div class="line">├── app.babel.js                    node 执行文件入口 （babel引导）</div><div class="line">├── app.js                          web server 入口文件</div><div class="line">├── gulpfile.js                     gulp 配置文件</div><div class="line">├── index.html                      view 首页</div><div class="line">├── node_modules                    依赖文件夹 （npm install 后会出现）</div><div class="line">├── package.json                    依赖管理配置文件</div><div class="line">├── config.json                     项目配置文件</div><div class="line">├── README.md                       README</div><div class="line">├── .babelrc                        babel 配置文件</div><div class="line">├── .bin                            脚本文件夹 （格式化文件脚本）</div><div class="line">├── .gitignore                      git 忽略规则</div><div class="line">├── doc                             文档文件夹</div><div class="line">├── demo                            demo </div><div class="line">├── ui                              页面构建组提供的 ui 文件夹</div><div class="line">├── development                     开发环境编译打包后产出目录</div><div class="line">├── test                            测试环境编译打包后产出目录</div><div class="line">├── pre-production                  预生产环境编译打包后产出目录</div><div class="line">└── production                      生产环境编译打包后产出目录</div></pre></td></tr></table></figure>
</code></pre><h4 id="业务结构划分"><a href="#业务结构划分" class="headerlink" title="业务结构划分"></a>业务结构划分</h4><ul>
<li><p>登录<br>  <code>/src/js/component/login/index.vue</code><br>  <code>/#!/login</code></p>
</li>
<li><p>欢迎页<br>  <code>/src/js/component/dashboard/index.vue</code><br>  <code>/#!/dashboard</code></p>
</li>
<li><p>用户管理<br>  <code>/src/js/component/dashboard/account-manage.vue</code><br>  <code>/#!/dashboard/account-manage</code></p>
</li>
<li><p>聊天记录查询<br>  <code>/src/js/component/dashboard/chat-record.vue</code><br>  <code>/#!/dashboard/chat-record</code></p>
</li>
<li><p>常用语<br>  <code>/src/js/component/dashboard/common-msg.vue</code><br>  <code>/#!/dashboard/common-msg</code></p>
</li>
<li><p>系统配置管理<br>  <code>/src/js/component/dashboard/config.vue</code><br>  <code>/#!/dashboard/config</code></p>
</li>
<li><p>修改密码<br>  <code>/src/js/component/dashboard/password.vue</code><br>  <code>/#!/dashboard/password</code></p>
</li>
<li><p>IM<br>  <code>/src/js/component/im/index.vue</code><br>  <code>/#!/im</code> </p>
</li>
</ul>
<h2 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h2><ul>
<li><p><code>git checkout dev</code> 切换到dev更新到最新版本</p>
</li>
<li><p><code>git checkout pre-release</code> 切换到pre-release分支</p>
</li>
<li><p><code>git merge dev</code> merge dev分支到pre-release分支</p>
</li>
<li><p><code>git checkout release</code> 切换到release 分支</p>
</li>
<li><p><code>git checkout pre-release ./src index.html package.json gulpfile.js</code> 将 <code>./src index.html package.json gulpfile.js</code> 等指定文件merge过来</p>
</li>
<li><p><code>npm run buildall</code>  生成开发、测试、预生产、生产四个环境的待发布包裹</p>
</li>
<li><p><code>git commit -am &quot;提交信息&quot;</code>  提交所有变动</p>
</li>
<li><p><code>git push origin release --force</code>  覆盖式推送到远程release分支</p>
</li>
<li><p>通知BS发布对应环境的包裹</p>
</li>
</ul>
<h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><ul>
<li><p><code>git clone http://gitlab.intra.gomeplus.com/gomeplusFED/CSP.git</code></p>
</li>
<li><p><code>cd CSP</code></p>
</li>
<li><p><code>npm install -d</code></p>
</li>
<li><p><code>npm run localdev</code> 本地开发，连接AMP平台</p>
</li>
<li><p><code>npm run localtest</code> 本地开发，连接后台人员本机</p>
</li>
<li><p><code>node app.babel.js</code> 开启本地静态资源服务</p>
</li>
<li><p><code>ifconfig(mac)\ipconfig(win)</code> 查看ip</p>
</li>
<li><p><code>http://</code> +  ip  +  <code>:1234/#!/login</code> 访问地址</p>
</li>
<li><p>可以通过修改 <code>/src/js/config/http.json</code> 文件改变各个环境地址   </p>
</li>
<li><p><code>http.json</code> 文件</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"localdev"</span>: <span class="string">"http://10.69.205.26:9090/mock/5742c66eb094235129ee29b5"</span>,</div><div class="line">    <span class="attr">"localtest"</span>: <span class="string">"http://10.125.2.43:6080/venus-crm-rest"</span>,</div><div class="line">    <span class="attr">"development"</span>:<span class="string">"http://10.69.201.13:8080/venus-crm-rest"</span>,</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"http://10.125.2.43:6080/venus-crm-rest"</span>,</div><div class="line">    <span class="attr">"pre-production"</span>: <span class="string">"http://10.125.2.10:8093/venus-crm-rest/"</span>,</div><div class="line">    <span class="attr">"production"</span>: <span class="string">"http://10.125.139.206:8093/venus-crm-rest"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h2&gt;&lt;p&gt;Vue是一个构建数据驱动的 web 界面的库，也就是一个以 MVVM 为核心的库。  &lt;/p&gt;
&lt;h4 id=&quot;为什么选择Vue&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的sublime配置</title>
    <link href="http://luoye.pw/blog/2016/06/23/%E6%88%91%E7%9A%84sublime%E9%85%8D%E7%BD%AE/"/>
    <id>http://luoye.pw/blog/2016/06/23/我的sublime配置/</id>
    <published>2016-06-23T02:10:51.000Z</published>
    <updated>2016-07-13T03:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能插件"><a href="#功能插件" class="headerlink" title="功能插件"></a>功能插件</h2><ul>
<li><p>Emmet</p>
<p>  写 <code>html</code> 的利器，不用多说</p>
</li>
<li><p>Babel  </p>
<p>  不仅能够识别更多的js方言，让sublime有正确的着色，而且能够支持ES6的语法提示等</p>
</li>
<li><p>HTML-CSS-JS Prettify</p>
<p>  支持 <code>html</code> <code>css</code> <code>js</code> 文件的格式化，快捷键 <code>command + shift + H</code></p>
</li>
<li><p>Markdown Preview</p>
<p>  markdown 预览</p>
</li>
<li><p>MarkdownEditing</p>
<p>  markdown 高亮</p>
</li>
</ul>
<h2 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h2><ul>
<li><p>Colorsublime</p>
<p>  非常多非常多的配色，使用方法，安装完成后， <code>ctl+shift+p</code> (Windows/Linux) 或者 <code>⇧+⌘+p</code> (OSX)，选择 <code>Colorsublime: Install Theme</code> 移动光标选择配色  </p>
<p>  <img src="https://packagecontrol.io/readmes/img/1cc8d20def6ff58d8311b67c5e791c20bc15aa6e.gif" alt=""></p>
</li>
<li><p>Theme - Soda  </p>
<p>  配色相当友好的主题，我的配置是 <code>&quot;theme&quot;: &quot;Soda Dark 3.sublime-theme&quot;</code></p>
</li>
<li><p>One Dark Color Scheme</p>
<p>  仿 Atom 的语法着色，完成度百分百</p>
</li>
</ul>
<h2 id="放几张图"><a href="#放几张图" class="headerlink" title="放几张图"></a>放几张图</h2><blockquote>
<p>代码<br><img src="./1.png" alt=""></p>
<p>Markdown<br><img src="./2.png" alt=""></p>
</blockquote>
<p>想开箱即用？打开 <code>Preferences -&gt; Browse Packages</code>，备份 <code>Packahes</code> 文件下的内容，在此文件夹打开命令行，执行 <code>git clone https://github.com/luoye-fe/sublimeTextConfig.git ./</code>，完成后打开 sublime 等待各种插件安装完成即可。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;功能插件&quot;&gt;&lt;a href=&quot;#功能插件&quot; class=&quot;headerlink&quot; title=&quot;功能插件&quot;&gt;&lt;/a&gt;功能插件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Emmet&lt;/p&gt;
&lt;p&gt;  写 &lt;code&gt;html&lt;/code&gt; 的利器，不用多说&lt;/p&gt;
&lt;/li&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中的异步流程控制--Promise/Generator/Async/Await</title>
    <link href="http://luoye.pw/blog/2016/06/09/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-Promise-Generators-Async-Await/"/>
    <id>http://luoye.pw/blog/2016/06/09/js中的异步流程控制-Promise-Generators-Async-Await/</id>
    <published>2016-06-09T00:05:14.000Z</published>
    <updated>2016-11-08T02:29:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>长文预警 ～</p>
</blockquote>
<p>异步I/O、事件驱动使JS这个单线程语言在不阻塞的情况下可以并行的执行很多任务，这带来了性能的极大提升，并且更加符合人们的自然认识（烧一壶水，期间你肯定不会等着水烧开再去做别的事，异步才是正常的啊！）。然而异步风格也给流程控制，错误处理带来了更多的麻烦。</p>
<h3 id="一、回调"><a href="#一、回调" class="headerlink" title="一、回调"></a>一、回调</h3><p>回调是JS的基础，函数可以作为参数传递并在恰当的时机执行，比如有下面的三个函数：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f1();</div><div class="line">f2();</div><div class="line">f3();</div></pre></td></tr></table></figure>
<p>如果 <code>f1</code> 中存在异步操作，比如 <code>ajax</code> 请求，并且 <code>f2</code> 需要在 <code>f1</code> 执行完毕之后执行，那么可以使用回调的方式改写函数，如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</div><div class="line">	$.ajax(&#123;</div><div class="line">		<span class="attr">url</span>: <span class="string">'...'</span>,</div><div class="line">		<span class="attr">type</span>: <span class="string">'get'</span>,</div><div class="line">		<span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			cb &amp;&amp; cb();</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="comment">// do something after f1 complete ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="comment">// do something else</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">f1(f2);</div><div class="line">f3();</div></pre></td></tr></table></figure>
<p>使用这种方式， <code>f1</code> 的异步操作，不会阻碍程序的运行，并且可以很方便的控制函数的执行过程，显然，我要说但是了。如果你看到下面的代码，估计你不会觉得回调有那么美好了。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">f1(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">	f2(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">		f3(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">			f4(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">				f5(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">		  			f6(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">		    			<span class="comment">// maybe more ...</span></div><div class="line">		  			&#125;)</div><div class="line">				&#125;)</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>WTF?!</p>
<p>可以看出，回调的缺点很明显，各个函数高度耦合，代码结构混乱，<code>debug</code> 困难，等等。  </p>
<h3 id="二、事件监听（观察者模式）"><a href="#二、事件监听（观察者模式）" class="headerlink" title="二、事件监听（观察者模式）"></a>二、事件监听（观察者模式）</h3><p>另一种解决异步流程控制的方法是采用事件监听的机制，某个事件的触发不再以某个时机为界限，而是取决于某个事件是否触发。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		Event.trigger(<span class="string">'loaded'</span>, argvs);</div><div class="line">	&#125;, <span class="number">2000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Event.on(<span class="string">'loaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">argvs</span>)</span>&#123;</div><div class="line">	<span class="comment">// do something ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">f1();</div></pre></td></tr></table></figure>
<p>唔，很美好的解决方案，但是观察者模式的缺点在其中也体现的很明显，事件的监听和触发散落在不同的地方，程序趋于复杂之后，<code>Event</code> 机制的复杂度也极大提高，明显这不是我们追求的。  </p>
<h3 id="三、异步流程控制库"><a href="#三、异步流程控制库" class="headerlink" title="三、异步流程控制库"></a>三、异步流程控制库</h3><p>为了优雅的解决异步流程控制的问题，伟大的猿们前赴后继，产出了很多方案，造就了不少优秀的库，包括但不限于 <code>q</code> <code>co</code> <code>async</code> 等。  </p>
<p>这些库的具体实现或使用方式不在本文的谈论范围，暂时跳过。  </p>
<h3 id="四、新标准、新未来"><a href="#四、新标准、新未来" class="headerlink" title="四、新标准、新未来"></a>四、新标准、新未来</h3><blockquote>
<p>重点来了！</p>
</blockquote>
<p>现在已经是2016年了，<code>ES</code> 的标准一代快过一代，有了 <code>bable</code> 这样的工具，甚至 <code>ES7</code> 都不再是不可触及的 <code>feture</code>了，新的标准当然对异步控制做出了很多努力，让我们一个一个来看。  </p>
<h4 id="1、Promise"><a href="#1、Promise" class="headerlink" title="1、Promise"></a>1、Promise</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise - MDN</a></p>
<p>所谓的 <code>Promise</code> ，就是一个特殊的用于传递异步信息的对象，它代表一个未完成的但是将会完成的操作。也就是说，<code>Promise</code> 代表了某个未来才会知道结果的事件（通常是一个异步操作），并且为这个异步事件提供统一的 <code>API</code>，能够让使用者准确的控制异步操作的每一个流程。  </p>
<h6 id="a-基本理解"><a href="#a-基本理解" class="headerlink" title="a. 基本理解"></a>a. 基本理解</h6><ul>
<li><p>一个 <code>Promise</code> 对象，存在三种状态， <code>pending(进行中)</code>、<code>resolve(已完成)</code>、<code>reject(已失败)</code>。一个异步操作的开始，对应着 <code>Promise</code> 的 <code>pending</code> 状态，异步操作的结束，对应着另两种状态，当异步操作成功时，对应着 <code>resolve</code>状态，失败时对应着 <code>reject</code>状态。</p>
</li>
<li><p><code>Promise</code> 的状态如果发生改变，就不能再被更改，并且，只能由 <code>pending</code> 向另外两种状态转变，不能逆，也不能 <code>resolve</code> 和 <code>reject</code> 互相转化。  </p>
</li>
</ul>
<h6 id="b-基本-API"><a href="#b-基本-API" class="headerlink" title="b. 基本 API"></a>b. 基本 API</h6><ul>
<li><code>Promise.resolve()</code> </li>
<li><code>Promise.reject()</code></li>
<li><code>Promise.prototype.then()</code></li>
<li><code>Promise.prototype.catch()</code></li>
<li><code>Promise.all()</code></li>
<li><code>Promise.race()</code></li>
</ul>
<h6 id="c-详解"><a href="#c-详解" class="headerlink" title="c. 详解"></a>c. 详解</h6><ul>
<li><p>创建 <code>Promise</code> 实例</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">	<span class="comment">// async operation ...</span></div><div class="line">	<span class="keyword">if</span>( <span class="comment">/* async operation success */</span> )&#123;</div><div class="line">		resolve(value);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		reject(err);</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  构造函数 <code>Promise</code> 接受一个函数作为参数，这个函数又有两个类型为方法的参数，<code>resolve</code> 、 <code>reject</code>。<code>resolve</code> 方法用来将 <code>promise</code> 从 <code>pending</code> 状态转换到 <code>resolve</code> 状态，并且将异步操作成功后返回的内容传递出去，<code>reject</code> 方法用来将 <code>promise</code> 从 <code>pending</code> 状态转换到 <code>reject</code> 状态，在异步操作失败时调用，并传递错误信息。  </p>
</li>
<li><p>调用</p>
<p>  <code>Promise</code> 实例创建后，可以调用 <code>then</code> 方法，处理异步操作成功或失败的状态。  </p>
<p>  <code>then</code> 方法接受两个函数参数，第一个即为创建 <code>Promise</code> 实例时的 <code>resolve</code> 函数，第二个则为创建 <code>Promise</code> 实例时的 <code>reject</code> 函数，用来分别处理异步操作成功，或失败的后续操作。当然，第二个用来处理失败的参数为可选参数。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">	<span class="comment">// async operation success</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="comment">// async operation failed</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>示例1: <code>sleep</code> 函数</p>
<p>  在很多编程语言中，都有着 <code>sleep</code> 函数，延迟程序执行，<code>javascript</code> 中可以用 <code>setTimeout</code> 完成操作的延迟执行，但是还是需要使用回调的方式，现在让我们用 <code>Promise</code> 来实现。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span>(<span class="params">ms</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		setTimeout(resolve, ms);</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 休眠1000ms后执行</span></div><div class="line">sleep(<span class="number">1000</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'1000s gone'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  一个简单的休眠函数就完成了，调用更加方便，也更加直观。  </p>
</li>
<li><p>示例2: 异步 <code>Ajax</code> 请求</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 封装下原生 XMLHttpRequest 操作</span></div><div class="line"><span class="keyword">var</span> ajaxExample = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">		client.open(params.type, params.url);</div><div class="line">		client.onreadystatechange = handler;</div><div class="line">		client.send();</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</div><div class="line">				resolve(<span class="keyword">this</span>.response);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">return</span> promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">ajaxExample(&#123;</div><div class="line">	<span class="attr">url</span>: <span class="string">'/test'</span>,</div><div class="line">	<span class="attr">type</span>: <span class="string">'GET'</span>,</div><div class="line">	<span class="attr">data</span>: &#123;</div><div class="line">		<span class="attr">page</span>: <span class="number">2</span></div><div class="line">	&#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.prototype.then()</code></p>
<p>  上面两个简单的示例，展示了 <code>Promise</code> 的基本使用方法，让我们再来看看具体的 <code>API</code>。  </p>
<p>  <code>then</code> 方法除了用于处理 <code>Promise</code> 实例的成功或失败操作，还会返回一个新的 <code>Promise</code> 实例，并且将返回值传递给下一层 <code>then</code> 方法，即：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sleep(<span class="number">1000</span>)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'1000s gone'</span>)</div><div class="line">		<span class="keyword">return</span> <span class="string">'123'</span></div><div class="line">	&#125;)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(val) <span class="comment">// 123</span></div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
<p>  这样来看，曾经使用多层嵌套的回调来控制异步流程的代码终于可以下岗了。</p>
</li>
<li><p><code>Promise.prototype.catch()</code></p>
<p>  在 <code>then</code> 方法中，第二个参数可以对当前 <code>Promise</code> 中的错误进行处理，为了统一的错误处理，<code>Promise</code> 也为我们提供了一个更加方便的错误处理方式。  </p>
<p>  当一个 <code>Promise</code> 实例转变为 <code>reject</code> 状态的时候，会调用 <code>catch</code> 中的回调函数，并且把首次 <code>reject</code> 的错误传递进去。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">	reject(<span class="string">'error test'</span>);</div><div class="line">&#125;)</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(err); <span class="comment">// error test</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  <code>catch</code> 能够捕获 <code>reject</code> 主动抛出的错误，同样也能捕获 <code>Promise</code> 运行中的错误。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error test'</span>);</div><div class="line">&#125;)</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(err); <span class="comment">// Error: error test(…)</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  <code>catch</code> 捕获错误时具有冒泡属性，即在最后调用 <code>catch</code> 时，能够捕获到此前所有 <code>Promise</code> 中的错误。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ajaxExample(&#123;</div><div class="line">	<span class="attr">url</span>: <span class="string">'/test'</span>,</div><div class="line">	<span class="attr">type</span>: <span class="string">'GET'</span>,</div><div class="line">	<span class="attr">data</span>: &#123;</div><div class="line">		<span class="attr">page</span>: <span class="number">2</span></div><div class="line">	&#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res)</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="comment">// 处理前两个 Promise 中的错误</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  上面的示例中，最后的 <code>catch</code> 方法能够捕获到前两个 <code>Promise</code> 中任意一个产生的错误。  </p>
</li>
<li><p><code>Promise.all()</code></p>
<p>  <code>Promise.all</code> 方法用于将多个Promise实例，包装成一个新的Promise实例。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allPromise = <span class="built_in">Promise</span>.all([p1, p2, p3])</div></pre></td></tr></table></figure>
<p>  <code>Promise.all</code> 接受一个由多个 <code>Promise</code> 实例组成的数组，如果数组中存在非 <code>Promise</code> 的示例，则 <code>allPromise</code> 的状态直接为 <code>reject</code>。  </p>
<p>  <code>allPromise</code> 的状态由 <code>p1/p2/p3</code> 共同决定，三个全部 <code>resolve</code> 则 <code>allPromise</code> 转变为 <code>resolve</code> ，其中任意一个出现 <code>reject</code> ，则 <code>allPromise</code> 转变为 <code>reject</code> 。  </p>
</li>
<li><p><code>Promise.race()</code></p>
<p>  <code>Promise.race</code> 方法同样用于将多个Promise实例，包装成一个新的Promise实例。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allPromise = <span class="built_in">Promise</span>.all([p1, p2, p3])</div></pre></td></tr></table></figure>
<p>  与 <code>Promise.all</code> 不同的是，如果 <code>p1/p2/p3</code> 中有任意一个状态先发生了变化，则 <code>allPromise</code> 的状态也会跟着转变，并且状态与最先发生状态改变的 <code>promise</code> 一致。  </p>
</li>
</ul>
<h6 id="d-实际应用"><a href="#d-实际应用" class="headerlink" title="d. 实际应用"></a>d. 实际应用</h6><ul>
<li><p>图片加载</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preloadImg = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">		img.onload = resolve;</div><div class="line">		img.onerror = reject;</div><div class="line">		img.src = url;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="keyword">var</span> img1 = preloadImg(<span class="string">'./img/test1.png'</span>);</div><div class="line"><span class="keyword">var</span> img2 = preloadImg(<span class="string">'./img/test2.png'</span>);</div><div class="line"><span class="keyword">var</span> img3 = preloadImg(<span class="string">'./img/test3.png'</span>);</div><div class="line"><span class="keyword">var</span> img4 = preloadImg(<span class="string">'./img/test4.png'</span>);</div><div class="line"><span class="built_in">Promise</span></div><div class="line">	.all([img1, img2, img3, img4])</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">// all img loaded</span></div><div class="line">		$(<span class="string">'.loading'</span>).hide();</div><div class="line">	&#125;)</div><div class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">		<span class="comment">// catch err</span></div><div class="line">		<span class="built_in">console</span>.log(err);</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>Promise</code> 风格的文件读写</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span>(err) &#123;</div><div class="line">				reject(err);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				resolve(data);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> writeFile = <span class="function"><span class="keyword">function</span>(<span class="params">path, data</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		fs.writeFile(path, data, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span>(err)&#123;</div><div class="line">				reject(err);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				resolve(data);</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">readFile(<span class="string">'./test.json'</span>)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(data);</div><div class="line">		<span class="keyword">return</span> data;</div><div class="line">	&#125;)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">		<span class="comment">// replace all 'abc' to 'ABC'</span></div><div class="line">		writeFile(<span class="string">'./test.json'</span>, data.replace(<span class="regexp">/abc/g</span>, <span class="string">'ABC'</span>));</div><div class="line">	&#125;)</div><div class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(err);</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2、Generator"><a href="#2、Generator" class="headerlink" title="2、Generator"></a>2、Generator</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Generator - MDN</a></p>
<p>想象这样的一个场景：  </p>
<blockquote>
<p>当你执行一个函数的时候，需要在某个时间点停下来等待另一个操作完成，并且拿到这个操作的执行结果，然后继续执行。</p>
</blockquote>
<p>这样的场景就是 <code>ES6</code> 的生成器需要解决的问题。  </p>
<h6 id="a-基本理解-1"><a href="#a-基本理解-1" class="headerlink" title="a. 基本理解"></a>a. 基本理解</h6><ul>
<li><p>生成器本质上是一种特殊的<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3" target="_blank" rel="external">迭代器</a>，迭代最简单的例子如下：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">	<span class="comment">// 每一次循环就是一次迭代，每次迭代都依赖上一次的 i 的值</span></div><div class="line">	<span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  而生成器作为一种特殊的迭代器就是它的每一次迭代都是可控的，详情下面将具体描述。  </p>
</li>
<li><p>生成器形式上是一种函数，只不过比普通的函数 <code>function</code> 多一个 <code>*</code> ，即 <code>function*(){}</code>。  </p>
</li>
</ul>
<h6 id="b-基本API"><a href="#b-基本API" class="headerlink" title="b. 基本API"></a>b. 基本API</h6><ul>
<li><code>function*(){}</code></li>
<li><code>yield</code></li>
<li><code>Generator.prototype.next()</code></li>
<li><code>Generator.prototype.return()</code></li>
<li><code>Generator.prototype.throw()</code></li>
<li><code>yield*</code></li>
</ul>
<h6 id="c-详解-1"><a href="#c-详解-1" class="headerlink" title="c. 详解"></a>c. 详解</h6><ul>
<li><p><code>Generator</code> 函数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'!'</span>;</div><div class="line">	<span class="keyword">return</span> <span class="string">'func end'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> helloWorld = test();</div></pre></td></tr></table></figure>
<p>  上面的例子就是一个简单的 <code>Generator</code> 函数，可以发现，函数声明是多个一个 <code>*</code>，并且函数体内出现了多个 <code>yield</code> 语句和 <code>return</code> 语句，即该生成器函数存在四种迭代状态： <code>hello</code> <code>world</code> <code>!</code> <code>return</code></p>
<p>  但是当我们执行上述代码的时候，发现并没有即时的执行，返回的也不是它的执行结果，而是一个生成器对象，只有当调用这个生成器对象的 <code>next</code> 方法，才会依次的执行函数语句，直到遇到 <code>yield</code> 语句或 <code>return</code> 语句。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "hello", done: false&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "world", done: false&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "!", done: false&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "func end", done: true&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>  <img src="./1.png" style="margin-left: 0;"></p>
<p>  让我们梳理一下上述代码的执行流程。  </p>
<p>  第一次调用 <code>next</code>： 生成器函数开始执行，遇到 <code>yield</code> 语句，暂停执行。<code>next</code> 返回一个对象，其中将当前 <code>yeild</code> 语句的值 <code>hello</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>false</code>，迭代未结束。</p>
<p>  第二次调用 <code>next</code>： 从上一个 <code>yield</code> 语句开始执行，遇到 <code>yield</code> 语句，暂停执行。<code>next</code> 返回一个对象，其中将当前 <code>yeild</code> 语句的值 <code>world</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>false</code>，迭代未结束。</p>
<p>  第三次调用 <code>next</code>： 从上一个 <code>yield</code> 语句开始执行，遇到 <code>yield</code> 语句，暂停执行。<code>next</code> 返回一个对象，其中将当前 <code>yeild</code> 语句的值 <code>!</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>false</code>，迭代未结束。</p>
<p>  第四次调用 <code>next</code>： 从上一个 <code>yield</code> 语句开始执行，遇到 <code>return</code> 语句，结束执行。<code>next</code> 返回一个对象，其中将当前 <code>return</code> 语句的值 <code>func end</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>true</code>，迭代结束。</p>
<p>  第五次调用 <code>next</code>： 生成器函数已经迭代（运行）完毕，<code>next</code> 方法始终返回 <code>{value: undefined, done: true}</code></p>
<p>  让我们再用一个例子来了解一下 <code>yield</code> 语句的执行流程：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'func start'</span>);</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(i &lt; <span class="number">6</span>)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'yield start'</span>);</div><div class="line">		<span class="keyword">yield</span> i;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'yield end'</span>); </div><div class="line">		i++;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'func end'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div></pre></td></tr></table></figure>
<p>  <img src="./2.png" style="margin-left: 0;"></p>
<p>  首次调用 <code>next</code> ，函数开始执行，遇到 <code>yield</code> 暂停执行，将 <code>yield</code> 语句后的表达式运行后返回，当作 <code>next</code> 方法返回值的 <code>value</code> 字段，依次调用 <code>next</code> ，从上次 <code>yield</code> 处继续运行，直到遇到下一个 <code>yield</code>，循环往复。  </p>
</li>
<li><p><code>yield</code> 语句</p>
<p>  通过上面的例子， <code>yield</code> 语句的特性已经很明显：  </p>
<ul>
<li><p><code>yield</code> 语句会暂停生成器函数的执行</p>
</li>
<li><p><code>yield</code> 语句后表达式的运行结果将作为 <code>next</code> 语句返回值中的 <code>value</code> 字段</p>
</li>
</ul>
</li>
<li><p><code>Generator.prototype.next()</code></p>
<p>  <code>next</code> 语句的返回值有两个字段 <code>value</code> 和 <code>done</code> ，<code>value</code> 为当前 <code>next</code> 指向的 <code>yield</code> 语句的返回值，<code>done</code> 标识当前生成器函数是否迭代完毕。  </p>
<p>  <code>next</code> 方法还可以接受任意一个参数，该参数将作为上一个 <code>yield</code> 返回值。 </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params">i</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">		<span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</div><div class="line">		<span class="keyword">if</span>(reset)&#123;</div><div class="line">			i = reset;</div><div class="line">		&#125;</div><div class="line">		i++;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div><div class="line"></div><div class="line">genEx.next();  <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">genEx.next();  <span class="comment">// &#123;value: 2, done: false&#125;</span></div><div class="line">genEx.next(<span class="number">10</span>);  <span class="comment">// &#123;value: 11, done: false&#125;</span></div></pre></td></tr></table></figure>
<p>  上面的代码实现了一个无限的迭代器，在每次运行到 <code>yield</code> 语句时，如果调用指向此次 <code>yield</code> 语句的 <code>next</code> 方法没有参数，那么 <code>reset</code> 的值始终是 <code>undefined</code>。只有在调用 <code>next</code> 方法传入了参数，此次执行 <code>yield</code> 语句时，<code>yield</code> 语句的返回值将变为 <code>next</code> 传入的参数。这样的特性能够让我们用同步的方式写出异步执行的代码，具体例子下文。  </p>
</li>
<li><p><code>Generator.prototype.return()</code></p>
<p>  当我们想在外部结束生成器函数的迭代，可以使用 <code>return</code> 方法，并将 <code>return</code> 方法的参数作为返回值。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div><div class="line"></div><div class="line">genEx.next();  <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">genEx.return(<span class="string">'end'</span>);  <span class="comment">// &#123;value: 'end', done: true&#125;</span></div><div class="line">genEx.next();  <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Generator.prototype.return()</code></p>
<p>  <code>throw</code> 方法允许我们在生成器函数外部抛出错误，并在内部捕获。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		<span class="keyword">yield</span>;</div><div class="line">	&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'inner error: '</span> + e);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div><div class="line">genEx.next();</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">	genEx.throw(<span class="string">'a'</span>);</div><div class="line">	genEx.throw(<span class="string">'b'</span>);</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'outer error: '</span> + e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// inner error: a</span></div><div class="line"><span class="comment">// outer error: b</span></div></pre></td></tr></table></figure>
<p>  第一次抛出错误，被生成器函数捕获到，第二次再抛出，由于 <code>catch</code> 语句已经在第一次执行过了，所以内部无法再次捕获错误，从而在外部的 <code>try catch</code> 语句中可以捕获到错误。  </p>
</li>
<li><p><code>yield*</code></p>
<p>  如果想在生成器函数中调用另一个生成器函数，将会用到 <code>yield*</code> 语句。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen1 = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'1'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'2'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> gen2 = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'a'</span>;</div><div class="line">	<span class="keyword">yield</span>* gen1();</div><div class="line">	<span class="keyword">yield</span> <span class="string">'b'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen2();</div><div class="line"></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "a", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "1", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "2", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "b", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="d-实际应用-1"><a href="#d-实际应用-1" class="headerlink" title="d. 实际应用"></a>d. 实际应用</h6><ul>
<li><p>异步 <code>Ajax</code> 请求</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params">url</span>)</span>&#123;</div><div class="line">	<span class="comment">// fetch: 原生的ajax请求API</span></div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</div><div class="line">	<span class="built_in">console</span>.log(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> genEx = gen(<span class="string">'https://api.github.com/users/github'</span>);</div><div class="line"><span class="keyword">var</span> result = genEx.next();</div><div class="line"></div><div class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res);</div><div class="line">	<span class="keyword">return</span> res.json();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">	genEx.next(data.bio);  <span class="comment">// How people build software.</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  上面的代码中，第一次调用 <code>next</code> 方法，开始请求，拿到返回结果后，用结果中的 <code>value</code>（ <code>fetch</code> 返回的是一个 <code>Promise</code>，所以需要 <code>then</code> 方法调用），调用下一次 <code>then</code> 从而执行生成器函数中 <code>yield</code> 后面的代码。  </p>
<p>  可以看出，虽然生成器函数将异步操作表示的很简洁，但是流程管理并不是很直接，即何时执行第一阶段，何时执行第二阶段并不能很好的向使用者展示。  </p>
</li>
</ul>
<h4 id="3、Async-Await"><a href="#3、Async-Await" class="headerlink" title="3、Async/Await"></a>3、Async/Await</h4><p>从回调，到 <code>Promise</code>，再到 <code>Generator</code> 函数，js的异步流程控制一直在进化，但是每种解决方法都无形的增加了额外的复杂度，都需要理解底层的运行机制才能很好的运用。  </p>
<p>而 <code>ES7</code> 提出的 <code>Async/Await</code>，大概也许可能是 JavaScript 中最好的异步解决方案。  </p>
<h6 id="a-实例"><a href="#a-实例" class="headerlink" title="a. 实例"></a>a. 实例</h6><ul>
<li><p>异步读取文件</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">// 与上文一致</span></div><div class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span>(err) &#123;</div><div class="line">				reject(err);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				resolve(data);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> file1 = <span class="keyword">await</span> readFile(<span class="string">'./test1.json'</span>);</div><div class="line">	<span class="keyword">var</span> file2 = <span class="keyword">await</span> readFile(<span class="string">'./test2.json'</span>);</div><div class="line">	<span class="built_in">console</span>.log(file1);</div><div class="line">	<span class="built_in">console</span>.log(file2);	</div><div class="line">&#125;</div><div class="line">asyncReadFile();</div></pre></td></tr></table></figure>
<p>  如果把上面的代码写成 <code>Geneerator</code> 风格，你会发现两者很相似。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> asyncReadFile = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'./test1.json'</span>);</div><div class="line">	<span class="keyword">var</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'./test2.json'</span>);</div><div class="line">	<span class="built_in">console</span>.log(file1);</div><div class="line">	<span class="built_in">console</span>.log(file2);	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  对比之后，其实 <code>async</code> 函数就是把 <code>*</code> 替换成 <code>async</code>，把 <code>yield</code> 替换成 <code>await</code>。  </p>
<p>  可以说，<code>async</code> 其实就是对 <code>Geneerator</code> 的语法糖，只不过多包了一层，改进了很多。  </p>
<p>  第一，使用 <code>async</code> 函数不用再手动的调用 <code>next</code> 方法来执行每一次迭代</p>
<p>  第二，更好的语义，<code>async</code> 表示这个函数是一个异步函数，<code>await</code> 表示此后的操作需要等待此步操作完成</p>
<p>  第三，侵入性更低，原生的 <code>try catch</code> 语句能处理错误，<code>async</code> 函数中的 <code>await</code> 语句不用做特殊处理，<code>Promise</code> 可以，原始的同步操作也可以  </p>
<p>  第四，更直观、更灵活的调用，<code>async</code> 函数返回的是一个 <code>Promise</code> 对象，异步操作完成后可以直接用 <code>then</code> 方法进行下一步操作  </p>
<p>  第五，简单的API，只有 <code>async</code> 和 <code>await</code> 两个API，<code>async</code> 用来声明一个异步函数，<code>await</code> 用来等待一个异步操作  </p>
</li>
<li><p><code>sleep</code> 函数</p>
<p>  上文我们用 <code>Promise</code> 实现了一个异步风格的 <code>sleep</code> 函数，现在让我们看看如何用同步的风格实现并使用它。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span>(<span class="params">ms</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		setTimeout(resolve, ms)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sleepEx = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'begin'</span>);</div><div class="line">	<span class="keyword">await</span> sleep(<span class="number">1000</span>);</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'end after 1000ms'</span>);</div><div class="line">&#125;</div><div class="line">sleepEx();</div></pre></td></tr></table></figure>
<p>  完美～</p>
</li>
</ul>
<h6 id="b-如何使用"><a href="#b-如何使用" class="headerlink" title="b. 如何使用"></a>b. 如何使用</h6><p><code>async</code> <code>await</code> 特性属于ES7的新特性，目前的ES运行环境中并没有实现这样的功能，但是借助 <code>babel</code>，我们可以很方便的使用这些新特性。  </p>
<p>这个展开讲又是一个大话题～贴一个 <code>bable</code> 转换代码的网址：<a href="https://babeljs.io/repl/#?evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Cstage-0" target="_blank" rel="external">Babel transform online</a>  </p>
<p>如何在线下使用，自行谷歌，或者，再来一篇？哈哈  </p>
<h3 id="五、结束"><a href="#五、结束" class="headerlink" title="五、结束"></a>五、结束</h3><p>长长的文章终于结束了，呼～  </p>
<p>主要的目的就是对异步流程的解决方案进行一下梳理，加深对js异步特性的理解。最推荐的方式还是ES7的新特性，毕竟是既有的新标准，使用的过程还能学习下 <code>babel</code> 的配置，哈哈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;长文预警 ～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;异步I/O、事件驱动使JS这个单线程语言在不阻塞的情况下可以并行的执行很多任务，这带来了性能的极大提升，并且更加符合人们的自然认识（烧一壶水，期间你肯定不会等着水烧开再去做别的事，异步才是正常
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>会声会影安装与激活</title>
    <link href="http://luoye.pw/blog/2016/06/05/%E4%BC%9A%E5%A3%B0%E4%BC%9A%E5%BD%B1%E5%AE%89%E8%A3%85%E4%B8%8E%E6%BF%80%E6%B4%BB/"/>
    <id>http://luoye.pw/blog/2016/06/05/会声会影安装与激活/</id>
    <published>2016-06-05T14:58:54.000Z</published>
    <updated>2016-06-16T10:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="http://www.huishenghuiying.com.cn/xiazai.html#selctbuy" target="_blank" rel="external">会声会影下载</a></li>
<li><a href="https://hostr.co/file/FDp8MOYlRuHv/AppNee.com.Corel.X5-X9.All.Products.Universal.Keygen.7z?warning=on" target="_blank" rel="external">会声会影注册机下载</a></li>
</ul>
<h2 id="安装（x8版本）"><a href="#安装（x8版本）" class="headerlink" title="安装（x8版本）"></a>安装（x8版本）</h2><h4 id="1、找到下载好的以-exe-为结尾的安装文件，将后缀名改为-rar，然后打开此压缩包（不是解压，用360压缩等工具打开）"><a href="#1、找到下载好的以-exe-为结尾的安装文件，将后缀名改为-rar，然后打开此压缩包（不是解压，用360压缩等工具打开）" class="headerlink" title="1、找到下载好的以 .exe 为结尾的安装文件，将后缀名改为 .rar，然后打开此压缩包（不是解压，用360压缩等工具打开）"></a>1、找到下载好的以 <code>.exe</code> 为结尾的安装文件，将后缀名改为 <code>.rar</code>，然后打开此压缩包（不是解压，用360压缩等工具打开）</h4><h4 id="2、打开压缩包中的-setup-xml"><a href="#2、打开压缩包中的-setup-xml" class="headerlink" title="2、打开压缩包中的 setup.xml"></a>2、打开压缩包中的 <code>setup.xml</code></h4><ul>
<li>搜索 <code>SHOWSERIALDIALOG</code>，将其 <code>value</code> 改为 <code>true</code></li>
<li>搜索 <code>SERIALNUMBER</code>，将其 <code>value</code> 删除</li>
</ul>
<blockquote>
<p>修改前<br><img src="./1.png" alt=""></p>
<p>修改后<br><img src="./2.png" alt=""></p>
</blockquote>
<p>然后将 <code>.rar</code> 改回 <code>.exe</code></p>
<h4 id="3、断开网络链接"><a href="#3、断开网络链接" class="headerlink" title="3、断开网络链接"></a>3、断开网络链接</h4><h4 id="4、打开注册机，选择产品为-Corel-VideoStudio-Pro-Ulitime-X8"><a href="#4、打开注册机，选择产品为-Corel-VideoStudio-Pro-Ulitime-X8" class="headerlink" title="4、打开注册机，选择产品为 Corel VideoStudio Pro/Ulitime X8"></a>4、打开注册机，选择产品为 <code>Corel VideoStudio Pro/Ulitime X8</code></h4><p><img src="./3.png" alt=""></p>
<h4 id="5、双击打开安装包"><a href="#5、双击打开安装包" class="headerlink" title="5、双击打开安装包"></a>5、双击打开安装包</h4><ul>
<li><p>勾选接受协议，下一步<br><img src="./4.png" alt=""></p>
</li>
<li><p>要求输入序列号<br><img src="./5.png" alt=""></p>
</li>
<li><p>拷贝注册机中生成的序列号<br><img src="./6.png" alt=""></p>
</li>
<li><p>粘贴在输入框内，点击下一步<br><img src="./7.png" alt=""></p>
</li>
<li><p>位置默认，视频标准默认，安装位置自定义，点击立即安装，等待安装完成<br><img src="./8.png" alt=""></p>
</li>
</ul>
<h4 id="6、打开会声会影主程序，第一次打开会提示为试用版30天，有功能限制，无视。待程序打开后，关闭程序"><a href="#6、打开会声会影主程序，第一次打开会提示为试用版30天，有功能限制，无视。待程序打开后，关闭程序" class="headerlink" title="6、打开会声会影主程序，第一次打开会提示为试用版30天，有功能限制，无视。待程序打开后，关闭程序"></a>6、打开会声会影主程序，第一次打开会提示为试用版30天，有功能限制，无视。待程序打开后，关闭程序</h4><blockquote>
<p>这个地方有可能出现打开主程序提示试用版然后打不开软件的情况，此时，链接上网络，双击 <code>Corel FastFlick X8</code>，会出现提示注册的界面，输入邮箱进行注册，如下</p>
</blockquote>
<p><img src="./9.png" alt=""><br><img src="./10.png" alt=""></p>
<blockquote>
<p>点击下一步，完成后关闭页面</p>
</blockquote>
<ul>
<li>出现如下界面时，断开网络链接，根据箭头指示点击</li>
</ul>
<p><img src="./11.png" alt=""></p>
<p><img src="./12.png" alt=""></p>
<ul>
<li>在注册机中输入安装码（只能手工输入，注意连字符）<br><img src="./13.png" alt=""></li>
</ul>
<p><img src="./14.png" alt=""></p>
<ul>
<li>点击 <code>Generate Activation Code</code> 生成激活码<br><img src="./15.png" alt=""></li>
<li>复制生成好的激活码<br><img src="./16.png" alt=""></li>
<li>粘贴在安装程序激活码位置<br><img src="./17.png" alt=""></li>
<li>点击下一步完成激活<br><img src="./18.png" alt=""></li>
<li>链接网络，打开主程序，已成功激活<br><img src="./19.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;资源&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.huishenghuiying.com.cn/xiazai.html#selctbuy&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack-workflow</title>
    <link href="http://luoye.pw/blog/2016/05/24/webpack-workflow/"/>
    <id>http://luoye.pw/blog/2016/05/24/webpack-workflow/</id>
    <published>2016-05-24T06:28:24.000Z</published>
    <updated>2016-05-24T06:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端工作流中要解决的问题"><a href="#前端工作流中要解决的问题" class="headerlink" title="前端工作流中要解决的问题"></a>前端工作流中要解决的问题</h2><ul>
<li>资源管理：模块化、组件化、依赖管理等</li>
<li>开发流程：dev、debug、proxy、build、deploy</li>
<li>周边工具：图形化界面、命令行辅助、自动化工程</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><a href="http://webpack.github.io/" target="_blank" rel="external">webpack官网</a>  </li>
<li>Webpack 是当下最热门的前端资源模块化管理和打包工具。它  <ul>
<li>能把散碎的静态资源通过一定的规则打包在一起  </li>
<li>还可以require几乎所有的静态资源，包括但不限于CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS、 Vue、 Jade、Ejs 等等  </li>
<li>还可以将代码切割成不同的chunk，实现按需加载，异步加载</li>
<li>还可以极精细的控制所有静态资源的版本  </li>
<li>还可以实现代码热替换，开发模式下，不用刷新浏览器，不用实时编译，自身的socket-io已经把内存中的代码换成最新的  </li>
<li>还可以 <code>SourceUrls</code> 和 <code>SourceMaps</code>，易于调试</li>
<li>还可以和前端最新的技术栈完美融合（Vue、React），针对这两个在webpack中有一整套的工具链  </li>
<li>还可以使用 <code>Plugin</code> 插件，实现各种定制化任务  </li>
<li>还可以和 <code>gulp/grunt</code> 等构建工具协同作战，完成极其复杂的任务  </li>
<li>还原生支持增量编译，发布代码再也不用等个好几分钟  </li>
</ul>
</li>
</ul>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><ul>
<li><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>  用 <code>webpack</code> 来做模块化，简直神器。  </p>
<p>  前端的模块化一直是一个很受人关注的问题，不同的加载器实现方式都不一样。<code>lithe/requireJs/seaJs</code>，这样的预加载器都有自己的一套实现方式，一定程度上解决了js的模块化问题，但是不同的实现方式，让我们不得不对不同的库做兼容性处理，让加载器能够识别，无疑增加了工作量和降低了模块的通用度。即使现在ES6提出了统一的标准，但是离实际使用还有很长的距离。  </p>
<p>  所以，有一个足够灵活，足够强大的模块加载器是个必要的选择。  </p>
<p>  在 <code>webpack</code> 中，同时支持 CommonJS、AMD和ES6，灵活性有保证。  </p>
<p>  并且在 <code>webpack</code> 的设计理念中，所有的静态资源都是模块，所以借助强大的 <code>loader</code> 系统几乎可以加载任意类型的静态资源，并且对模块的输出结果可以做非常精细的控制，根据不同的配置可以达到任意想要的结果。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">loaders: [&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'jsx-loader?harmony'</span></div><div class="line">&#125;, &#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/.vue$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'vue-loader'</span></div><div class="line">&#125;,&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/.css$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'style-loader'</span></div><div class="line">&#125;,&#123;</div><div class="line">	<span class="attr">test</span>: <span class="regexp">/\.(jpe?g|png|gif|svg)$/i</span>,</div><div class="line">	<span class="attr">loaders</span>: [</div><div class="line">	    <span class="string">'image?&#123;bypassOnDebug: true, progressive:true, optimizationLevel: 3, pngquant:&#123;quality: "65-80"&#125;&#125;'</span>,</div><div class="line">	    <span class="string">'url?limit=10000&amp;name=img/[hash:8].[name].[ext]'</span>,</div><div class="line">	]</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>  这是 <code>webpack</code> 配置文件中的 <code>loaders</code> 部分，其中，<code>test</code> 是正则匹配，匹配到的文件将使用相应的 <code>loader</code> 去解析，然后这些文件就成为了模块，可以在其它地方引用。比如：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="comment">// 加载js</span></div><div class="line"><span class="keyword">var</span> login = <span class="built_in">require</span>(<span class="string">'./src/js/conf/login/login.js'</span>);</div><div class="line"></div><div class="line"><span class="comment">// js文件会被webpack包装，并赋予单独ID，exports出去</span></div><div class="line"></div><div class="line"><span class="comment">// 加载css</span></div><div class="line"><span class="built_in">require</span>(<span class="string">'./src/css/login.css'</span>);</div><div class="line"></div><div class="line"><span class="comment">// css文件会被以style标签插入到head中，当然，也可以通过ExtractTextPlugin这样的插件以link标签插入到页面中</span></div><div class="line"></div><div class="line"><span class="comment">// 加载图片</span></div><div class="line"><span class="keyword">var</span> btnImg = <span class="built_in">require</span>(<span class="string">'./src/img/btn.png'</span>);</div><div class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</div><div class="line">img.src = btnImg;</div><div class="line"></div><div class="line"><span class="comment">// 根据上面的配置，小于10k的图片直接dataurl到src中，并且打包后自动添加hash值，当然，在js中引用，hash值部分也相应的会变化。</span></div><div class="line"></div><div class="line"><span class="comment">// 加载vue单文件组件</span></div><div class="line"><span class="keyword">var</span> loginCom = <span class="built_in">require</span>(<span class="string">'./src/js/components/login.vue'</span>);</div><div class="line"></div><div class="line"><span class="comment">// vue有单独的loader读取vue单文件组件</span></div><div class="line"></div><div class="line"><span class="comment">// 所有模块的加载可以做很多灵活的配置，比如，文件hash值、小于一定大小的图片dataurl、打包后文件命名等</span></div><div class="line"><span class="comment">// jade模版，ejs模版，less文件，sass文件都可以直接require，不用预编译，直接用！</span></div></pre></td></tr></table></figure>
</li>
<li><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>  抛开现在流行的组件化解决方案，光以 <code>webpack</code> 的角度来看，如果模版，样式，脚本，都可以作为模块来引入，这就使得封装组件变的很简单。比如：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 搜索组件</span></div><div class="line"><span class="comment">// js/component/search/index.js</span></div><div class="line"></div><div class="line"><span class="built_in">require</span>(<span class="string">'js/component/search/index.css'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> tpl = <span class="built_in">require</span>(<span class="string">'js/component/search/template.ejs'</span>);</div><div class="line"><span class="keyword">var</span> htmlStr = tpl(&#123;<span class="attr">searchContent</span>: options.searchStr&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> launchSearch = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">	<span class="attr">launchSearch</span>: launchSearch,</div><div class="line">	<span class="attr">somethingelse</span>: <span class="string">'balabala'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>  使用：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// js/app.js</span></div><div class="line"><span class="keyword">var</span> searchComponent = <span class="built_in">require</span>(<span class="string">'js/component/search/index.js'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">	<span class="attr">searchStr</span>: <span class="string">'水果'</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">searchComponent.launchSearch(options);</div></pre></td></tr></table></figure>
<p>  这样的开发方式无疑能够极大降低维护成本，当然，如果和现在流行的前端框架，如React、Vue结合起来实现组件化，代码组织会更加清晰，自由度也更高，展开讲又是一个大话题，按下不表。  </p>
<p>  还是贴一下伪代码吧。。以 <code>Vue</code> 为例  </p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// alert.vue</div><div class="line"></div><div class="line">&lt;template&gt;</div><div class="line">    &lt;div class="alert" v-show="alertConfig.show" :class="alertConfig.type" transition="fade"&gt;</div><div class="line">        &lt;h4&gt;&#123;&#123;alertConfig.msg&#125;&#125;&lt;/h4&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;style&gt;</div><div class="line">// css 样式</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var Vue = require('Vue');</div><div class="line"></div><div class="line">var Alert = Vue.extend(&#123;</div><div class="line">    name: 'Alert',</div><div class="line">    prop: ['alertConfig']</div><div class="line">&#125;)</div><div class="line"></div><div class="line">module.exports = Alert;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>  使用  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.vue（同样是一个组件，可能被其它组件（如根组件）依赖）</span></div><div class="line"></div><div class="line">&lt;templeate&gt;</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">m-alert</span> <span class="attr">:alert-config</span>=<span class="string">"alertConfig"</span>&gt;</span><span class="tag">&lt;/<span class="name">m-alert</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'Vue'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Alert = <span class="built_in">require</span>(<span class="string">'alert.vue'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Main = Vue.extend(&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Main'</span>,</div><div class="line">    <span class="attr">data</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    	<span class="keyword">return</span> &#123;</div><div class="line">    		<span class="attr">alertConfig</span>: &#123;</div><div class="line">    			<span class="attr">show</span>: <span class="literal">false</span>,</div><div class="line">    			<span class="attr">type</span>: <span class="string">'info'</span>, <span class="comment">// info/success/warning/erro</span></div><div class="line">    			msg: <span class="string">'提示信息'</span></div><div class="line">    		&#125;</div><div class="line">    	&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">components</span>: &#123;</div><div class="line">    	<span class="string">'m-alert'</span>: Alert</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = Main;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>  这样的 <code>.vue</code> 组件通过 <code>webpack</code> 中的 <code>vue-loader</code> 插件就可以完成打包。  </p>
</li>
</ul>
<ul>
<li><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>  没有什么好说的。。。<code>npm</code>。<br>  毕竟绝大部分的流行库都在 <code>npm</code> 上，也都支持模块加载的方式。不排除有一些纯js库（jq插件）需要手动封装下。其实也很简单，如果都遵循 <code>CommonJs</code> 的加载方式，而且其中没有其它依赖的话，直接 <code>require</code> 即可，如果有依赖，大部分也是 <code>jq</code> 等，在文件最前面声明下 <code>var $ = require(&#39;jQuery&#39;)</code> 即可。<br>  这样，一个工程只需要维护一份 <code>package.json</code> ，不管是开发用的包，还是构建用的包都可以统一管理。  </p>
</li>
</ul>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>对于前端的开发流程，一直的想法是，我们能有一个统一的入口工具，不管是命令行还是图形化界面，可以把调试，代理，构建等一系列操作整合起来，并且尽可能的简化这样的操作，开发不用过多的关注构建问题，也不用为调试、构建浪费更多的精力。</p>
<ul>
<li><h3 id="dev、debug"><a href="#dev、debug" class="headerlink" title="dev、debug"></a>dev、debug</h3><p>  基于 <code>webpack</code> 的开发流程主要有两种方式：  </p>
<ul>
<li><p><code>webpack</code> 的实时构建模式  </p>
<p>  <code>webpack --watch</code> 每次修改代码都会实时的构建，增量的，很快，即使是用了 <code>uglify</code> 实时构建压缩也很快（不超过1s）  </p>
</li>
<li><p><code>webpack-dev-server</code>  </p>
<p>  <code>webpack-dev-server</code> 是一个小型的 <code>express</code> 服务器，它的原理就是使用 <code>webpack-dev-middleware</code> 中间件来为通过 <code>webpack</code> 生成的静态资源提供web服务。它的内部通过 <code>socket.io</code> 连接客户端，可以实时发送编译状态的信息到客户端，从而达到客户端代码的实时热更新，也就是 <code>HMR</code> <code>Hot Module Replacement</code>。  </p>
<p>  <code>webpack-dev-server</code> 支持命令行模式和 <code>NodeJs</code> 模式，命令行模式就是直接打开 <code>webpack-dev-server</code> 本地服务器，参数默认，配置灵活性稍低，但是简单快捷，如下：  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// --line 行内模式 | --hot 热替换</div><div class="line">webpack-dev-server --line --hot</div></pre></td></tr></table></figure>
<p>  在项目根目录行执行上面的命令之后，本地的 <code>webpack-dev-server</code> 服务器已经启动，此目录下的由 <code>webpack</code> 生成的静态资源都将被这个本地服务器托管。  </p>
<p>  以 GoH5 为例，把页面内引用的资源改为 <code>8080</code> 端口下对应的文件并加入 <code>http://localhost:8080/webpack-dev-server.js</code>，此时代码热更新已经生效：  </p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"GoH5，一款可视化的H5编辑器，拖拽、动画、事件，神奇的H5。"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"H5,可视化,cms,编辑器"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go H5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"/back/dist/css/goh5.min.css?ver=1.0.3"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/webpack-dev-server.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/vendor.min.js?ver=1.0.3"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/goh5.min.js?ver=1.0.3"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line">// 因为我的应用服务启动在 3030 端口，所以这里的地址写了绝对地址，如果同端口，直接写文件名即可</div></pre></td></tr></table></figure>
<p>  在控制台可以看到  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[HMR] Vue component hot reload shim applied. // 不同的热重载提示信息不同（Vue/React）</div><div class="line">[WDS] Hot Module Replacement enabled.</div></pre></td></tr></table></figure>
<p>  如果本地修改了代码可以看到  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[WDS] App updated. Recompiling...</div><div class="line">[WDS] App hot update...</div></pre></td></tr></table></figure>
<p>  同时，控制台也会输出相关的编译信息：  </p>
<p>  <img src="./1.png" alt="控制台"></p>
<p>  一个字。。。快。。。而且，浏览器并不用刷新呀 (有一定限定条件，并不是一切代码都可以热重载)  </p>
<p>  放一张官网的gif  </p>
<p>  <img src="http://blog.evanyou.me/images/vue-hot.gif" alt="hot-reload"></p>
<p>  上面的例子主要集中在Vue上，其实大同小异，并且 <code>webpack</code> 提供了 <code>webpack-dev-middleware</code> 中间件，可以定制一个本地的服务，完成很多任务。</p>
</li>
</ul>
</li>
</ul>
<h4 id="所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。"><a href="#所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。" class="headerlink" title="所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。"></a><strong>所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。</strong></h4><ul>
<li><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>  线上代码的代理调试，借助 <code>host</code>，借助 <code>Fiddler</code>，借助 <code>wamp</code>，其实。。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line">&#123;</div><div class="line">    <span class="attr">devServer</span>: &#123;</div><div class="line">        <span class="attr">proxy</span>: &#123;</div><div class="line">            <span class="string">'/some/path*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'https://js.meixincdn.com'</span>,</div><div class="line">                <span class="attr">secure</span>: <span class="literal">false</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  当然，这样的代理不够灵活，而且不能代理html，但是如果借助本地的服务，我们可以这么做   </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先行配置host，可以手动，也可以像 `fd-server` 有个图形化界面，然后  </span></div><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'koa-proxy'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">app.use(proxy(&#123;</div><div class="line">  	<span class="attr">host</span>: <span class="string">'https://localhost:8080/'</span>,</div><div class="line">  	<span class="attr">match</span>: <span class="regexp">/\/js.meixincdn.com\//</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>  上面达到的功能就是把 <code>js.meixincdn.com</code> 域名的资源转发到 <code>webpack-dev-server</code> ，然后就可以愉快的开始开发了  </p>
</li>
</ul>
<ul>
<li><h3 id="build、deploy"><a href="#build、deploy" class="headerlink" title="build、deploy"></a>build、deploy</h3><p>  这一块我的想法还是，放到测试机上去。。  </p>
<p>  测试机上可以跑一个 <code>gulp watch</code> 和 <code>webpack --watch</code> 的任务，本地提交了 <code>src</code> 目录下的文件，测试机检测到文件更新，直接编译，这样的编译都是增量的，肯定很快，然后再该怎么上线怎么上线，怎么发布怎么发布。本地就可以直接忽略 <code>dist</code> 目录的改变，不提交其中的内容。  </p>
<p>  还有一点，我是觉得 php 的 smarty 模版可以前端维护，就算不行，静态资源那一块也一定前端维护，这样不管是改时间戳还是直接hash，都很灵活啊～  </p>
</li>
</ul>
<h2 id="周边工具"><a href="#周边工具" class="headerlink" title="周边工具"></a>周边工具</h2><p>图形化界面、命令行辅助、自动化工程，高大上的整套解决方案，想想就激动。。。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前端工作流中要解决的问题&quot;&gt;&lt;a href=&quot;#前端工作流中要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;前端工作流中要解决的问题&quot;&gt;&lt;/a&gt;前端工作流中要解决的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;资源管理：模块化、组件化、依赖管理等&lt;/li&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用 webpack 构建 node 后端代码，使其支持 js 新特性并实现热重载</title>
    <link href="http://luoye.pw/blog/2016/04/12/use-webpack-in-your-node-app/"/>
    <id>http://luoye.pw/blog/2016/04/12/use-webpack-in-your-node-app/</id>
    <published>2016-04-12T09:52:18.000Z</published>
    <updated>2016-05-22T09:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>webpack 在前端领域的模块化和代码构建方面有着无比强大的功能，通过一些特殊的配置甚至可以实现前端代码的实时构建、ES6/7新特性支持以及热重载，这些功能同样可以运用于后台 nodejs 的应用，让后台的开发更加顺畅，服务更加灵活，怎么来呢？往下看。</p>
<p>先梳理下我们将要解决的问题：</p>
<ul>
<li>node端代码构建</li>
<li>ES6/7 新特性支持</li>
<li>node服务代码热重载</li>
</ul>
<h2 id="node端代码构建"><a href="#node端代码构建" class="headerlink" title="node端代码构建"></a>node端代码构建</h2><p>node端的代码其实是不用编译或者构建的，整个node的环境有它自己的一个模块化或者依赖机制，但是即使是现在最新的node版本，对ES6/7的支持还是捉襟见肘。当然使用一些第三方库可以做到支持类似 <code>async/await</code> 这样的语法，但是毕竟不是规范不是标准，这样看来，node端的代码还是有构建的需要的。这里我们选取的工具就是 <code>webpack</code> 以及它的一些 <code>loader</code>。   </p>
<p>首先，一个 <code>node app</code> 必定有一个入口文件 <code>app.js</code> ，按照 <code>webpack</code> 的规则，我们可以把所有的代码打包成一个文件 <code>bundle.js</code> ，然后运行这个 <code>bundle.js</code> 即可，<code>webpack.config.js</code> 如下：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpcak = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">	<span class="attr">entry</span>: [</div><div class="line">	    <span class="string">'./app.js'</span></div><div class="line">	],</div><div class="line">	<span class="attr">output</span>: &#123;</div><div class="line">	    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">	    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是有一个很严重的问题，这样打包的话，一些 <code>npm</code> 中的模块也会被打包进这个 <code>bundle.js</code>，还有 <code>node</code> 的一些原生模块，比如 <code>fs/path</code> 也会被打包进来，这明显不是我们想要的。所以我们得告诉 <code>webpack</code>，你打包的是 <code>node</code> 的代码，原生模块就不要打包了，还有 <code>node_modules</code> 目录下的模块也不要打包了，<code>webpack.config.js</code> 如下：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpcak = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> nodeModules = &#123;&#125;;</div><div class="line">fs.readdirSync(<span class="string">'node_modules'</span>)</div><div class="line">    .filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="string">'.bin'</span>].indexOf(x) === <span class="number">-1</span>;</div><div class="line">    &#125;)</div><div class="line">    .forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</div><div class="line">        nodeModules[mod] = <span class="string">'commonjs '</span> + mod;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">	<span class="attr">entry</span>: [</div><div class="line">	    <span class="string">'./app.js'</span></div><div class="line">	],</div><div class="line">	<span class="attr">output</span>: &#123;</div><div class="line">	    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">	    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">target</span>: <span class="string">'node'</span>,</div><div class="line">	<span class="attr">externals</span>: nodeModules</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要就是在 <code>webpack</code> 的配置中加上 <code>target: &#39;node&#39;</code> 告诉 <code>webpack</code> 打包的对象是 <code>node</code> 端的代码，这样一些原生模块 <code>webpack</code> 就不会做处理。另一个就是 <code>webpack</code> 的 <code>externals</code> 属性，这个属性的主要作用就是告知 <code>webpack</code> 在打包过程中，遇到 <code>externals</code> 中声明的模块不用处理。  </p>
<p>比如在前端中， <code>jQuery</code> 的包通过 CDN 的方式以 <code>script</code> 标签引入，如果此时在代码中出现 <code>require(&#39;jQuery&#39;)</code> ，并且直接用 <code>webpack</code> 打包比定会报错。因为在本地并没有这样的一个模块，此时就必须在 <code>externals</code> 中声明 <code>jQuery</code> 的存在。也就是 <code>externals</code> 中的模块，虽然没有被打包，但是是代码运行是所要依赖的，而这些依赖是直接存在在整个代码运行环境中，并不用做特殊处理。  </p>
<p>在 <code>node</code> 端所要做的处理就是过滤出 <code>node_modules</code> 中所有模块，并且放到 <code>externals</code>中。  </p>
<p>这个时候我们的代码应该可以构建成功了，并且是我们期望的形态，但是不出意外的话，你还是跑不起来，因为有不小的坑存在，继续往下看。   </p>
<ul>
<li><p>坑1：<code>__durname</code> <code>__filename</code> 指向问题</p>
<blockquote>
<p>打包之后的代码你会发现 <code>__durname</code> <code>__filename</code> 全部都是 <code>/</code> ，这两个变量在 <code>webpack</code> 中做了一些自定义处理，如果想要正确使用，在配置中加上  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">context: __dirname,</div><div class="line"><span class="attr">node</span>: &#123;</div><div class="line">    <span class="attr">__filename</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">__dirname</span>: <span class="literal">false</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>坑2：动态 <code>require</code> 的上下文问题</p>
<blockquote>
<p>这一块比较大，放到后面讲，跟具体代码有关，和配置无关  </p>
</blockquote>
</li>
<li><p>坑n：其它的还没发现，估摸不少，遇到了谷歌吧…</p>
</li>
</ul>
<h2 id="ES6-7-新特性支持"><a href="#ES6-7-新特性支持" class="headerlink" title="ES6/7 新特性支持"></a>ES6/7 新特性支持</h2><p>构建 <code>node</code> 端代码的目标之一就是使用ES6/7中的新特性，要实现这样的目标 <code>babel</code> 是我们的不二选择。  </p>
<p>首先，先安装 <code>babel</code> 的各种包 <code>npm install babel-core babel-loader babel-plugin-transform-runtime babel-preset-es2015 babel-preset-stage-0 --save-dev json-loader -d</code>  </p>
<p>然后修改 <code>webpack.config.js</code> ，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpcak = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> nodeModules = &#123;&#125;;</div><div class="line">fs.readdirSync(<span class="string">'node_modules'</span>)</div><div class="line">    .filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="string">'.bin'</span>].indexOf(x) === <span class="number">-1</span>;</div><div class="line">    &#125;)</div><div class="line">    .forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</div><div class="line">        nodeModules[mod] = <span class="string">'commonjs '</span> + mod;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">	<span class="attr">entry</span>: [</div><div class="line">	    <span class="string">'./app.js'</span></div><div class="line">	],</div><div class="line">	<span class="attr">output</span>: &#123;</div><div class="line">	    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">	    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">target</span>: <span class="string">'node'</span>,</div><div class="line">	<span class="attr">externals</span>: nodeModules,</div><div class="line">	<span class="attr">context</span>: __dirname,</div><div class="line">	<span class="attr">node</span>: &#123;</div><div class="line">	    <span class="attr">__filename</span>: <span class="literal">false</span>,</div><div class="line">	    <span class="attr">__dirname</span>: <span class="literal">false</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">module</span>: &#123;</div><div class="line">	    <span class="attr">loaders</span>: [&#123;</div><div class="line">	        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">	        <span class="attr">loader</span>: <span class="string">'babel-loader'</span>,</div><div class="line">	        <span class="attr">exclude</span>: [</div><div class="line">	            path.resolve(__dirname, <span class="string">"node_modules"</span>),</div><div class="line">	        ],</div><div class="line">	        <span class="attr">query</span>: &#123;</div><div class="line">	            <span class="attr">plugins</span>: [<span class="string">'transform-runtime'</span>],</div><div class="line">	            <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'stage-0'</span>],</div><div class="line">	        &#125;</div><div class="line">	    &#125;, &#123;</div><div class="line">	        <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,</div><div class="line">	        <span class="attr">loader</span>: <span class="string">'json-loader'</span></div><div class="line">	    &#125;]</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">resolve</span>: &#123;</div><div class="line">	    <span class="attr">extensions</span>: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>]</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要就是配置 <code>webpack</code> 中的 <code>loader</code> ，借此来编译代码。  </p>
<h2 id="node服务代码热重载"><a href="#node服务代码热重载" class="headerlink" title="node服务代码热重载"></a>node服务代码热重载</h2><p><code>webpack</code> 极其牛叉的地方之一，开发的时候，实时的构建代码，并且，实时的更新你已经加载的代码，也就是说，不用手动去刷新浏览器，即可以获取最新的代码并执行。  </p>
<p>这一点同样可以运用在 <code>node</code> 端，实现即时修改即时生效，而不是 <code>pm2</code> 那种重启的方式。  </p>
<p>首先，修改配置文件，如下： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">entry: [</div><div class="line">	<span class="string">'webpack/hot/poll?1000'</span>,</div><div class="line">    <span class="string">'./app.js'</span></div><div class="line">],</div><div class="line"><span class="comment">// ...</span></div><div class="line">plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这个时候，如果执行 <code>webpack --watch &amp; node app.js</code> ，你的代码修改之后就可以热重载而不用重启应用，当然，代码中也要做相应改动，如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hotModule = <span class="built_in">require</span>(<span class="string">'./hotModule'</span>);</div><div class="line"><span class="comment">// do something else</span></div><div class="line"></div><div class="line"><span class="comment">// 如果想要 hotModule 模块热重载</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</div><div class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./hotModule.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> newHotModule = <span class="built_in">require</span>(<span class="string">'./hotModule.js'</span>);</div><div class="line">        <span class="comment">// do something else</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>思路就是，如果需要某模块热重载，就把它包一层，如果修改了，<code>webpack</code> 重新打包了，重新 <code>require</code> 一遍，然后代码即是最新的代码。  </p>
<p>当然，如果你在某个需要热重载的模块中又依赖另一个模块，或者说动态的依赖了另一个模块，这样的模块并不会热重载。   </p>
<h2 id="webpack-动态-require"><a href="#webpack-动态-require" class="headerlink" title="webpack 动态 require"></a>webpack 动态 require</h2><p>动态 <code>require</code> 的场景包括：  </p>
<ul>
<li><p>场景一：在代码运行过程中遍历某个目录，动态 <code>reauire</code>，比如  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app.js</span></div><div class="line"><span class="keyword">var</span> rd = <span class="built_in">require</span>(<span class="string">'rd'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 遍历路由文件夹，自动挂载路由</span></div><div class="line"><span class="keyword">var</span> routers = rd.readFileFilterSync(<span class="string">'./routers'</span>, /\.js/);</div><div class="line">routers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">	<span class="built_in">require</span>(item);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  这个时候你会发现 <code>&#39;./routers&#39;</code> 下的require都不是自己想要的，然后在 <code>bundle.js</code> 中找到打包之后的相应模块后，你可以看到，动态 <code>require</code> 的对象都是 <code>app.js</code> 同级目录下的 <code>js</code> 文件，而不是 <code>&#39;./routers&#39;</code> 文件下的 <code>js</code> 文件。为什么呢？  </p>
<p>  <code>webpack</code> 在打包的时候，必须把你可能依赖的文件都打包进来，并且编上号，然后在运行的时候 <code>require</code> 相应的模块 <code>ID</code> 即可，这个时候 <code>webpack</code> 获取的动态模块，就不再是你指定的目录 <code>&#39;./routers&#39;</code> 了，而是相对于当前文件的目录，所以，必须修正 <code>require</code> 的上下文，修改如下：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取正确的模块</span></div><div class="line"><span class="keyword">var</span> req = <span class="built_in">require</span>.context(<span class="string">"./routers"</span>, <span class="literal">true</span>, /\.js$/);</div><div class="line"><span class="keyword">var</span> routers = rd.readFileFilterSync(<span class="string">'./routers'</span>, /\.js/);</div><div class="line">routers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">	<span class="comment">// 使用包涵正确模块的已经被修改过的 `require` 去获取模块</span></div><div class="line">	req(item);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>场景二：在 <code>require</code> 的模块中含有变量，比如  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(isMe ? <span class="string">'./a.js'</span> : <span class="string">'./b.js'</span>);</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">var</span> testMoule = <span class="built_in">require</span>(<span class="string">'./mods'</span> + name + <span class="string">'.js'</span>);</div></pre></td></tr></table></figure>
<p>  第一种的处理方式在 <code>webpack</code> 中的处理是把模块 <code>./a.js</code> <code>./b.js</code> 都包涵进来，根据变量不同 <code>require</code> 不同的模块。  </p>
<p>  第二种的处理方式和场景一类似，获取 <code>./mods/</code> 目录下的所有模块，然后重写了 <code>require</code> ，然后根据变量不同加载不通的模块，所以自己处理的时候方法类似。  </p>
</li>
</ul>
<h2 id="用-ES6-7-写-webpack-config-js"><a href="#用-ES6-7-写-webpack-config-js" class="headerlink" title="用 ES6/7 写 webpack.config.js"></a>用 ES6/7 写 webpack.config.js</h2><p>项目都用 ES6/7 了，配置文件也必须跟上。  </p>
<p>安装好 <code>babel</code> 编译所需要的几个依赖包，然后把 <code>webpack.config.js</code> 改为 <code>webpack.config.babel.js</code> ，然后新建 <code>.babelrc</code> 的 <code>babel</code> 配置文件，加入  </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后和往常一样执行 <code>webpack</code> 的相关命令即可。</p>
<p>完整 <code>webpack.config.babel.js</code> 如下：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">'webpack'</span>;</div><div class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> nodeModules = &#123;&#125;;</div><div class="line">fs.readdirSync(<span class="string">'node_modules'</span>)</div><div class="line">    .filter(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="string">'.bin'</span>].indexOf(x) === <span class="number">-1</span>;</div><div class="line">    &#125;)</div><div class="line">    .forEach(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</div><div class="line">        nodeModules[mod] = <span class="string">'commonjs '</span> + mod;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="attr">cache</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">entry</span>: [</div><div class="line">        <span class="string">'webpack/hot/poll?1000'</span>,</div><div class="line">        <span class="string">'./app.js'</span></div><div class="line">    ],</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">        <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">context</span>: __dirname,</div><div class="line">    <span class="attr">node</span>: &#123;</div><div class="line">        <span class="attr">__filename</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">__dirname</span>: <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">target</span>: <span class="string">'node'</span>,</div><div class="line">    <span class="attr">externals</span>: nodeModules,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [&#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'babel-loader'</span>,</div><div class="line">            <span class="attr">exclude</span>: [</div><div class="line">                path.resolve(__dirname, <span class="string">"node_modules"</span>),</div><div class="line">            ],</div><div class="line">            <span class="attr">query</span>: &#123;</div><div class="line">                <span class="attr">plugins</span>: [<span class="string">'transform-runtime'</span>],</div><div class="line">                <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'stage-0'</span>],</div><div class="line">            &#125;</div><div class="line">        &#125;, &#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'json-loader'</span></div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</div><div class="line">    ],</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">        <span class="attr">extensions</span>: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大致流程就是如此，坑肯定还有，遇到的话手动谷歌吧～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack 在前端领域的模块化和代码构建方面有着无比强大的功能，通过一些特殊的配置甚至可以实现前端代码的实时构建、ES6/7新特性支持以及热重载，这些功能同样可以运用于后台 nodejs 的应用，让后台的开发更加顺畅，服务更加灵活，怎么来呢？往下看。&lt;/p&gt;
&lt;p&gt;先梳
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mobile-debug</title>
    <link href="http://luoye.pw/blog/2016/03/20/mobile-debug/"/>
    <id>http://luoye.pw/blog/2016/03/20/mobile-debug/</id>
    <published>2016-03-20T05:53:44.000Z</published>
    <updated>2016-05-21T07:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="UC浏览器开发版（仅限安卓平台）"><a href="#UC浏览器开发版（仅限安卓平台）" class="headerlink" title="UC浏览器开发版（仅限安卓平台）"></a>UC浏览器开发版（仅限安卓平台）</h4><blockquote>
<p>超级强大，样式、脚本、资源，都可以调试，而且UC在移动端份额最大，针对性很高。</p>
</blockquote>
<p>1、 <a href="http://plus.uc.cn/document/webapp/doc5.html" target="_blank" rel="external">UC浏览器开发版</a></p>
<p>2、 官方的文档已经很详细了，包括两种调试方法，无线和有线。有线的调试很复杂，需要ADB工具，需要数据线，所以还是直接无线调试比较好。</p>
<p>3、 无线调试方法简记：</p>
<ul>
<li>安卓手机安装UC浏览器的开发版</li>
<li>保证手机和电脑在同一个局域网</li>
<li>记录下手机的ip地址，比如手机ip为 <code>10.69.5.150</code></li>
<li>在UC浏览器中打开需要调试的页面</li>
<li>电脑上打开 <code>10.69.5.150:9998</code> 即可开始开心的调试（和chrome控制台相差不大）</li>
</ul>
<h4 id="weinre本地服务器（全平台）"><a href="#weinre本地服务器（全平台）" class="headerlink" title="weinre本地服务器（全平台）"></a>weinre本地服务器（全平台）</h4><blockquote>
<p>weinre是专门的网页调试工具，它会在本地创建一个监听服务器，然后你需要在被调试页面插入一个它提供的js，然后weinre就可以监听到，然后即可开始调试。</p>
</blockquote>
<p>1、 <a href="http://people.apache.org/~pmuellr/weinre/" target="_blank" rel="external">weinre官网</a></p>
<p>2、 <a href="https://www.npmjs.com/package/weinre" target="_blank" rel="external">weinre npm</a></p>
<p>3、 调试步骤</p>
<ul>
<li>本地全局安装weinre</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install weinre -g</div></pre></td></tr></table></figure>
<ul>
<li>启动本地 weinre 服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weinre --boundHost 10.69.5.10 --httpPort 9090</div></pre></td></tr></table></figure>
<ul>
<li>参数解释</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">--boundHost 10.69.5.10 : 在你局域网的地址开启服务</div><div class="line"></div><div class="line">--httpPort 9090 : 本地服务器监听端口，不设置默认为8080</div></pre></td></tr></table></figure>
<ul>
<li><p>访问pc调试界面<br>如果启动服务时指定了ip和端口，访问此ip的指定端口即可。<br>本例地址为： <code>http://10.69.5.10:9090/</code></p>
</li>
<li><p>在调试页面插入监听脚本<br>在调试页面中插入下图中 Target Script 中的js，本例即 <code>http://10.69.5.10:9090/target/target-script-min.js#anonymous</code>。<br><code>#anonymous</code> 这个是页面标志，不同的标志在选取目标调试页时可以起到识别作用。<br><img src="./1.png" alt=""><br>假设页面代码如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://10.69.5.10:9090/target/target-script-min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>在终端访问此页面（apache可以直接有个本地http服务，nodejs需要自己启一个）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在本地的2333端口开启服务，返回上面的测试页</span></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line"><span class="keyword">var</span> pwd = __dirname;</div><div class="line"><span class="keyword">var</span> port = <span class="number">2333</span>;</div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    res.sendFile(pwd + <span class="string">'/test.html'</span>)</div><div class="line">&#125;)</div><div class="line">app.listen(<span class="number">2333</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时访问 <code>10.69.5.10::2333</code> 就可以看到上面测试页的内容<br><img src="./2.png" alt=""></p>
<p>然后在局域网的其它终端访问此页面都可以看到<br><img src="./3.png" alt=""></p>
<p>此时打开 <code>http://10.69.5.10:9090/client/</code> 你会看到<br><img src="./4.png" alt=""></p>
<p>选中 Targets 里的地址即可开始调试，如下图<br><img src="./5.png" alt=""><br><img src="./6.png" alt=""></p>
<p>4、其它</p>
<p>weinre最大的缺点就是不能调试js，虽然它实现了一个简单的js解释器，能在自己的控制台操作dom，但是本身页面里的调试信息没法在这捕获，遗憾。<br>但是它支持全平台，不管是wap还是app，只要是前端的html页面，都可以调试，遇到一些奇葩的兼容性问题很好找。<br>如果真心用这个工具，我们还可以在测试服务器搭一个代理服务，任何线上页面走这个代理服务器，都会被注入那段监听的js，测试机访问代理服务器吐出的地址，pc机访问统一的控制台页面，本地什么配置都不用，就可以开始真机调试。<br>再深入的话也可以深究一下weinre的js调试问题，那就圆满了。。。脑洞ing。。。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;UC浏览器开发版（仅限安卓平台）&quot;&gt;&lt;a href=&quot;#UC浏览器开发版（仅限安卓平台）&quot; class=&quot;headerlink&quot; title=&quot;UC浏览器开发版（仅限安卓平台）&quot;&gt;&lt;/a&gt;UC浏览器开发版（仅限安卓平台）&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;超
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015年终总结</title>
    <link href="http://luoye.pw/blog/2015/12/31/2015%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://luoye.pw/blog/2015/12/31/2015年终总结/</id>
    <published>2015-12-31T14:22:22.000Z</published>
    <updated>2016-06-18T06:55:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>踏入社会的第一年，每年的年终总结应该记起来了。默默的定下一个应一直坚持的小事。</p>
</blockquote>
<p>2015，从校园到社会；2015，从徐州到北京；2015，从骆也到骆也。2015，颇具转折意义的一年。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>2015年初，还在焦急的等待考研的结果，或许自己已经知道答案。但是查到分数那一刻还是有点不甘心，回想之前一年为考研做的准备，哎，只能说，努力就好。</p>
<p>人最不应该的就是在原地等待。考研没有结果，我知道自己该做个选择了。选择什么？包括未来在内的所有一切。</p>
<p>毕业了选择什么职业？那时候脑海中的目标真心明确，就是前端。现在想想啊，真是为自己以一个纯文科愣头青身份去投身程序员行业而感到后怕。</p>
<p>3月11号，踏上北京的土地，灰蒙蒙的天，有点压抑，也有点兴奋。缔造了无数传说的帝都，我来了。</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>来北京后的大半个月，不断的面试，不断的被打击，不断的认识到自己是有多菜。</p>
<p>还记得去美食杰面试的时候，硕哥问我，jq的函数你知道几个，我回答说不知道。相信那时候硕哥的心里一定是崩溃的，内心os或许就是，小伙子，谁给你的勇气！</p>
<p>幸好硕哥最后的“判决”是，能给我个实习的岗位。就这样，在美食杰，踏上了自己的职业生涯，走上了前端这条道路。</p>
<p>工作的时间总是很快，一晃，在美食杰过去了大半年，没什么怨言，美食杰的每一位小伙伴都很棒，每天的工作也很充实，进步很快。但是当自己能够完全虐业务的所有需求之后，知道在美食杰已经到尽头了，是时候该走了。</p>
<p>前端入行，html标签不会几个，jq函数不知一个，现在？现在手里的项目是一个ng的cms系统，一个独立的web应用。</p>
<p>不敢说自己现在有多牛B，但是实打实的进步是自己敢拍着胸脯吹布尔的。</p>
<p>离开美食杰，转战新浪，从11月到现在，也两个月了，谈感受的话，挺好。厉害的人大大存在，不再和以前一样像过家家一样弄着前端了。但是觉得还是太慢，在前端路上走的越远，越认识到自己应该踏多大的步伐，走什么样的路。</p>
<p>选择道路，不一定十分十正确，但一定不要不去选择。</p>
<p>未来自己一定还是深入前端，希望自己能够快速成长起来，我会努力。</p>
<h3 id="美食杰"><a href="#美食杰" class="headerlink" title="美食杰"></a>美食杰</h3><p>美食杰，自己职业生涯的起点，真的有感情。</p>
<p>美食杰，带给自己的不仅是一份工作，更是一个平台，在这，学到了知识，锻炼了技能，更认识了很多新小伙伴。每一位都是收获。</p>
<p>还记得，李老爷，徐丹，我，三个人一起进的美食杰，然后中午吃啥，晚上走啊，周末干嘛，生活乐无忧。再然后是小唐，长相腼腆的男孩子，现在看来，大错特错！再然后，苏瑶，那个笑起来雾霾天都退散几步的姑娘。再然后，徐丹走了，欧美汇的鱼火锅加点酒，几个人大谈特谈，悠闲无比。再然后沈大人，一个地方来的小伙伴，年龄严重不符性格的家伙，正式开启了四人组的逗比生后。再然后。。嗯，还有好多个再然后，也还会有好多个再然后。</p>
<p>附上离开美食杰的 <a href="/html/cizhixin.html">辞职信</a> ，哈哈，虽然并没有用上，现在看看好傻。。</p>
<h3 id="过往"><a href="#过往" class="headerlink" title="过往"></a>过往</h3><p>大学的小伙伴们啊，你们还好嘛？</p>
<p>六月份的毕业照灰尘都没有落上，但相信每个人都不再一样。或许离开校园，联系已经多余，往后的日子也不会有过多的交集，但是请记得同窗四年的我们，一定是那时候最纯粹的友谊。</p>
<p>大学的小圈子原定元旦回徐州小聚，但各有各的事，只能搁浅，小小的遗憾。</p>
<h3 id="定音"><a href="#定音" class="headerlink" title="定音"></a>定音</h3><p>总结没个总结的样子了，。。想到哪写哪了，总之加油吧。</p>
<p>16年马上就来，目标要有，梦想更要有。</p>
<p>至于是啥？梦中再做个总结去，哈哈哈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;踏入社会的第一年，每年的年终总结应该记起来了。默默的定下一个应一直坚持的小事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2015，从校园到社会；2015，从徐州到北京；2015，从骆也到骆也。2015，颇具转折意义的一年。&lt;/p&gt;
&lt;h3 id=
    
    </summary>
    
    
  </entry>
  
</feed>

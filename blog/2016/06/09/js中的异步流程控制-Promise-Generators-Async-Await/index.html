<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> js中的异步流程控制--Promise/Generator/Async/Await · LUOYE</title><meta name="description" content="js中的异步流程控制--Promise/Generator/Async/Await - Luoye"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/blog/favicon.ico"><link rel="stylesheet" href="/blog/css/apollo.css"><style type="text/css">@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 400;
    src: local('Source Sans Pro'), local('SourceSansPro-Regular'), url(//fontstatic.useso.com/s/sourcesanspro/v9/ODelI1aHBYDBqgeIAH2zlCxe5Tewm2_XWfbGchcXw4g.woff2) format('woff2');
    unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 400;
    src: local('Source Sans Pro'), local('SourceSansPro-Regular'), url(//fontstatic.useso.com/s/sourcesanspro/v9/ODelI1aHBYDBqgeIAH2zlIa1YDtoarzwSXxTHggEXMw.woff2) format('woff2');
    unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 400;
    src: local('Source Sans Pro'), local('SourceSansPro-Regular'), url(//fontstatic.useso.com/s/sourcesanspro/v9/ODelI1aHBYDBqgeIAH2zlJbPFduIYtoLzwST68uhz_Y.woff2) format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 600;
    src: local('Source Sans Pro Semibold'), local('SourceSansPro-Semibold'), url(//fontstatic.useso.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGMZXFz2iDKd7GJNSaxRYiSj3rGVtsTkPsbDajuO5ueQw.woff2) format('woff2');
    unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
}
@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 600;
    src: local('Source Sans Pro Semibold'), local('SourceSansPro-Semibold'), url(//fontstatic.useso.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGKyGJhAh-RE0BxGcd_izyev3rGVtsTkPsbDajuO5ueQw.woff2) format('woff2');
    unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
    font-family: 'Source Sans Pro';
    font-style: normal;
    font-weight: 600;
    src: local('Source Sans Pro Semibold'), local('SourceSansPro-Semibold'), url(//fontstatic.useso.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGMzFoXZ-Kj537nB_-9jJhlA.woff2) format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}</style></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="https://luoyefe.com" target="_blank" class="nav-list-link">INDEX</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/luo-ye-42-22" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="https://github.com/luoye-fe" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">js中的异步流程控制--Promise/Generator/Async/Await</h1><div class="post-info">2016年6月9日</div><div class="post-content"><blockquote>
<p>长文预警 ～</p>
</blockquote>
<p>异步I/O、事件驱动使JS这个单线程语言在不阻塞的情况下可以并行的执行很多任务，这带来了性能的极大提升，并且更加符合人们的自然认识（烧一壶水，期间你肯定不会等着水烧开再去做别的事，异步才是正常的啊！）。然而异步风格也给流程控制，错误处理带来了更多的麻烦。</p>
<h3 id="一、回调"><a href="#一、回调" class="headerlink" title="一、回调"></a>一、回调</h3><p>回调是JS的基础，函数可以作为参数传递并在恰当的时机执行，比如有下面的三个函数：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f1();</div><div class="line">f2();</div><div class="line">f3();</div></pre></td></tr></table></figure>
<p>如果 <code>f1</code> 中存在异步操作，比如 <code>ajax</code> 请求，并且 <code>f2</code> 需要在 <code>f1</code> 执行完毕之后执行，那么可以使用回调的方式改写函数，如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</div><div class="line">	$.ajax(&#123;</div><div class="line">		<span class="attr">url</span>: <span class="string">'...'</span>,</div><div class="line">		<span class="attr">type</span>: <span class="string">'get'</span>,</div><div class="line">		<span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			cb &amp;&amp; cb();</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="comment">// do something after f1 complete ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="comment">// do something else</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">f1(f2);</div><div class="line">f3();</div></pre></td></tr></table></figure>
<p>使用这种方式， <code>f1</code> 的异步操作，不会阻碍程序的运行，并且可以很方便的控制函数的执行过程，显然，我要说但是了。如果你看到下面的代码，估计你不会觉得回调有那么美好了。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">f1(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">	f2(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">		f3(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">			f4(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">				f5(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">		  			f6(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">		    			<span class="comment">// maybe more ...</span></div><div class="line">		  			&#125;)</div><div class="line">				&#125;)</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>WTF?!</p>
<p>可以看出，回调的缺点很明显，各个函数高度耦合，代码结构混乱，<code>debug</code> 困难，等等。  </p>
<h3 id="二、事件监听（观察者模式）"><a href="#二、事件监听（观察者模式）" class="headerlink" title="二、事件监听（观察者模式）"></a>二、事件监听（观察者模式）</h3><p>另一种解决异步流程控制的方法是采用事件监听的机制，某个事件的触发不再以某个时机为界限，而是取决于某个事件是否触发。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		Event.trigger(<span class="string">'loaded'</span>, argvs);</div><div class="line">	&#125;, <span class="number">2000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Event.on(<span class="string">'loaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">argvs</span>)</span>&#123;</div><div class="line">	<span class="comment">// do something ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">f1();</div></pre></td></tr></table></figure>
<p>唔，很美好的解决方案，但是观察者模式的缺点在其中也体现的很明显，事件的监听和触发散落在不同的地方，程序趋于复杂之后，<code>Event</code> 机制的复杂度也极大提高，明显这不是我们追求的。  </p>
<h3 id="三、异步流程控制库"><a href="#三、异步流程控制库" class="headerlink" title="三、异步流程控制库"></a>三、异步流程控制库</h3><p>为了优雅的解决异步流程控制的问题，伟大的猿们前赴后继，产出了很多方案，造就了不少优秀的库，包括但不限于 <code>q</code> <code>co</code> <code>async</code> 等。  </p>
<p>这些库的具体实现或使用方式不在本文的谈论范围，暂时跳过。  </p>
<h3 id="四、新标准、新未来"><a href="#四、新标准、新未来" class="headerlink" title="四、新标准、新未来"></a>四、新标准、新未来</h3><blockquote>
<p>重点来了！</p>
</blockquote>
<p>现在已经是2016年了，<code>ES</code> 的标准一代快过一代，有了 <code>bable</code> 这样的工具，甚至 <code>ES7</code> 都不再是不可触及的 <code>feture</code>了，新的标准当然对异步控制做出了很多努力，让我们一个一个来看。  </p>
<h4 id="1、Promise"><a href="#1、Promise" class="headerlink" title="1、Promise"></a>1、Promise</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise - MDN</a></p>
<p>所谓的 <code>Promise</code> ，就是一个特殊的用于传递异步信息的对象，它代表一个未完成的但是将会完成的操作。也就是说，<code>Promise</code> 代表了某个未来才会知道结果的事件（通常是一个异步操作），并且为这个异步事件提供统一的 <code>API</code>，能够让使用者准确的控制异步操作的每一个流程。  </p>
<h6 id="a-基本理解"><a href="#a-基本理解" class="headerlink" title="a. 基本理解"></a>a. 基本理解</h6><ul>
<li><p>一个 <code>Promise</code> 对象，存在三种状态， <code>pending(进行中)</code>、<code>resolve(已完成)</code>、<code>reject(已失败)</code>。一个异步操作的开始，对应着 <code>Promise</code> 的 <code>pending</code> 状态，异步操作的结束，对应着另两种状态，当异步操作成功时，对应着 <code>resolve</code>状态，失败时对应着 <code>reject</code>状态。</p>
</li>
<li><p><code>Promise</code> 的状态如果发生改变，就不能再被更改，并且，只能由 <code>pending</code> 向另外两种状态转变，不能逆，也不能 <code>resolve</code> 和 <code>reject</code> 互相转化。  </p>
</li>
</ul>
<h6 id="b-基本-API"><a href="#b-基本-API" class="headerlink" title="b. 基本 API"></a>b. 基本 API</h6><ul>
<li><code>Promise.resolve()</code> </li>
<li><code>Promise.reject()</code></li>
<li><code>Promise.prototype.then()</code></li>
<li><code>Promise.prototype.catch()</code></li>
<li><code>Promise.all()</code></li>
<li><code>Promise.race()</code></li>
</ul>
<h6 id="c-详解"><a href="#c-详解" class="headerlink" title="c. 详解"></a>c. 详解</h6><ul>
<li><p>创建 <code>Promise</code> 实例</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">	<span class="comment">// async operation ...</span></div><div class="line">	<span class="keyword">if</span>( <span class="comment">/* async operation success */</span> )&#123;</div><div class="line">		resolve(value);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		reject(err);</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  构造函数 <code>Promise</code> 接受一个函数作为参数，这个函数又有两个类型为方法的参数，<code>resolve</code> 、 <code>reject</code>。<code>resolve</code> 方法用来将 <code>promise</code> 从 <code>pending</code> 状态转换到 <code>resolve</code> 状态，并且将异步操作成功后返回的内容传递出去，<code>reject</code> 方法用来将 <code>promise</code> 从 <code>pending</code> 状态转换到 <code>reject</code> 状态，在异步操作失败时调用，并传递错误信息。  </p>
</li>
<li><p>调用</p>
<p>  <code>Promise</code> 实例创建后，可以调用 <code>then</code> 方法，处理异步操作成功或失败的状态。  </p>
<p>  <code>then</code> 方法接受两个函数参数，第一个即为创建 <code>Promise</code> 实例时的 <code>resolve</code> 函数，第二个则为创建 <code>Promise</code> 实例时的 <code>reject</code> 函数，用来分别处理异步操作成功，或失败的后续操作。当然，第二个用来处理失败的参数为可选参数。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">	<span class="comment">// async operation success</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="comment">// async operation failed</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>示例1: <code>sleep</code> 函数</p>
<p>  在很多编程语言中，都有着 <code>sleep</code> 函数，延迟程序执行，<code>javascript</code> 中可以用 <code>setTimeout</code> 完成操作的延迟执行，但是还是需要使用回调的方式，现在让我们用 <code>Promise</code> 来实现。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span>(<span class="params">ms</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		setTimeout(resolve, ms);</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 休眠1000ms后执行</span></div><div class="line">sleep(<span class="number">1000</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'1000s gone'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  一个简单的休眠函数就完成了，调用更加方便，也更加直观。  </p>
</li>
<li><p>示例2: 异步 <code>Ajax</code> 请求</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 封装下原生 XMLHttpRequest 操作</span></div><div class="line"><span class="keyword">var</span> ajaxExample = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">		client.open(params.type, params.url);</div><div class="line">		client.onreadystatechange = handler;</div><div class="line">		client.send();</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</div><div class="line">				resolve(<span class="keyword">this</span>.response);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">return</span> promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">ajaxExample(&#123;</div><div class="line">	<span class="attr">url</span>: <span class="string">'/test'</span>,</div><div class="line">	<span class="attr">type</span>: <span class="string">'GET'</span>,</div><div class="line">	<span class="attr">data</span>: &#123;</div><div class="line">		<span class="attr">page</span>: <span class="number">2</span></div><div class="line">	&#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.prototype.then()</code></p>
<p>  上面两个简单的示例，展示了 <code>Promise</code> 的基本使用方法，让我们再来看看具体的 <code>API</code>。  </p>
<p>  <code>then</code> 方法除了用于处理 <code>Promise</code> 实例的成功或失败操作，还会返回一个新的 <code>Promise</code> 实例，并且将返回值传递给下一层 <code>then</code> 方法，即：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sleep(<span class="number">1000</span>)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'1000s gone'</span>)</div><div class="line">		<span class="keyword">return</span> <span class="string">'123'</span></div><div class="line">	&#125;)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(val) <span class="comment">// 123</span></div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
<p>  这样来看，曾经使用多层嵌套的回调来控制异步流程的代码终于可以下岗了。</p>
</li>
<li><p><code>Promise.prototype.catch()</code></p>
<p>  在 <code>then</code> 方法中，第二个参数可以对当前 <code>Promise</code> 中的错误进行处理，为了统一的错误处理，<code>Promise</code> 也为我们提供了一个更加方便的错误处理方式。  </p>
<p>  当一个 <code>Promise</code> 实例转变为 <code>reject</code> 状态的时候，会调用 <code>catch</code> 中的回调函数，并且把首次 <code>reject</code> 的错误传递进去。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">	reject(<span class="string">'error test'</span>);</div><div class="line">&#125;)</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(err); <span class="comment">// error test</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  <code>catch</code> 能够捕获 <code>reject</code> 主动抛出的错误，同样也能捕获 <code>Promise</code> 运行中的错误。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error test'</span>);</div><div class="line">&#125;)</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(err); <span class="comment">// Error: error test(…)</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  <code>catch</code> 捕获错误时具有冒泡属性，即在最后调用 <code>catch</code> 时，能够捕获到此前所有 <code>Promise</code> 中的错误。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ajaxExample(&#123;</div><div class="line">	<span class="attr">url</span>: <span class="string">'/test'</span>,</div><div class="line">	<span class="attr">type</span>: <span class="string">'GET'</span>,</div><div class="line">	<span class="attr">data</span>: &#123;</div><div class="line">		<span class="attr">page</span>: <span class="number">2</span></div><div class="line">	&#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res)</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="comment">// 处理前两个 Promise 中的错误</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  上面的示例中，最后的 <code>catch</code> 方法能够捕获到前两个 <code>Promise</code> 中任意一个产生的错误。  </p>
</li>
<li><p><code>Promise.all()</code></p>
<p>  <code>Promise.all</code> 方法用于将多个Promise实例，包装成一个新的Promise实例。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allPromise = <span class="built_in">Promise</span>.all([p1, p2, p3])</div></pre></td></tr></table></figure>
<p>  <code>Promise.all</code> 接受一个由多个 <code>Promise</code> 实例组成的数组，如果数组中存在非 <code>Promise</code> 的示例，则 <code>allPromise</code> 的状态直接为 <code>reject</code>。  </p>
<p>  <code>allPromise</code> 的状态由 <code>p1/p2/p3</code> 共同决定，三个全部 <code>resolve</code> 则 <code>allPromise</code> 转变为 <code>resolve</code> ，其中任意一个出现 <code>reject</code> ，则 <code>allPromise</code> 转变为 <code>reject</code> 。  </p>
</li>
<li><p><code>Promise.race()</code></p>
<p>  <code>Promise.race</code> 方法同样用于将多个Promise实例，包装成一个新的Promise实例。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allPromise = <span class="built_in">Promise</span>.all([p1, p2, p3])</div></pre></td></tr></table></figure>
<p>  与 <code>Promise.all</code> 不同的是，如果 <code>p1/p2/p3</code> 中有任意一个状态先发生了变化，则 <code>allPromise</code> 的状态也会跟着转变，并且状态与最先发生状态改变的 <code>promise</code> 一致。  </p>
</li>
</ul>
<h6 id="d-实际应用"><a href="#d-实际应用" class="headerlink" title="d. 实际应用"></a>d. 实际应用</h6><ul>
<li><p>图片加载</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preloadImg = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">		img.onload = resolve;</div><div class="line">		img.onerror = reject;</div><div class="line">		img.src = url;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="keyword">var</span> img1 = preloadImg(<span class="string">'./img/test1.png'</span>);</div><div class="line"><span class="keyword">var</span> img2 = preloadImg(<span class="string">'./img/test2.png'</span>);</div><div class="line"><span class="keyword">var</span> img3 = preloadImg(<span class="string">'./img/test3.png'</span>);</div><div class="line"><span class="keyword">var</span> img4 = preloadImg(<span class="string">'./img/test4.png'</span>);</div><div class="line"><span class="built_in">Promise</span></div><div class="line">	.all([img1, img2, img3, img4])</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">// all img loaded</span></div><div class="line">		$(<span class="string">'.loading'</span>).hide();</div><div class="line">	&#125;)</div><div class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">		<span class="comment">// catch err</span></div><div class="line">		<span class="built_in">console</span>.log(err);</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>Promise</code> 风格的文件读写</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span>(err) &#123;</div><div class="line">				reject(err);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				resolve(data);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> writeFile = <span class="function"><span class="keyword">function</span>(<span class="params">path, data</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		fs.writeFile(path, data, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span>(err)&#123;</div><div class="line">				reject(err);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				resolve(data);</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line">readFile(<span class="string">'./test.json'</span>)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(data);</div><div class="line">		<span class="keyword">return</span> data;</div><div class="line">	&#125;)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">		<span class="comment">// replace all 'abc' to 'ABC'</span></div><div class="line">		writeFile(<span class="string">'./test.json'</span>, data.replace(<span class="regexp">/abc/g</span>, <span class="string">'ABC'</span>));</div><div class="line">	&#125;)</div><div class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(err);</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2、Generator"><a href="#2、Generator" class="headerlink" title="2、Generator"></a>2、Generator</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Generator - MDN</a></p>
<p>想象这样的一个场景：  </p>
<blockquote>
<p>当你执行一个函数的时候，需要在某个时间点停下来等待另一个操作完成，并且拿到这个操作的执行结果，然后继续执行。</p>
</blockquote>
<p>这样的场景就是 <code>ES6</code> 的生成器需要解决的问题。  </p>
<h6 id="a-基本理解-1"><a href="#a-基本理解-1" class="headerlink" title="a. 基本理解"></a>a. 基本理解</h6><ul>
<li><p>生成器本质上是一种特殊的<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3" target="_blank" rel="external">迭代器</a>，迭代最简单的例子如下：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">	<span class="comment">// 每一次循环就是一次迭代，每次迭代都依赖上一次的 i 的值</span></div><div class="line">	<span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  而生成器作为一种特殊的迭代器就是它的每一次迭代都是可控的，详情下面将具体描述。  </p>
</li>
<li><p>生成器形式上是一种函数，只不过比普通的函数 <code>function</code> 多一个 <code>*</code> ，即 <code>function*(){}</code>。  </p>
</li>
</ul>
<h6 id="b-基本API"><a href="#b-基本API" class="headerlink" title="b. 基本API"></a>b. 基本API</h6><ul>
<li><code>function*(){}</code></li>
<li><code>yield</code></li>
<li><code>Generator.prototype.next()</code></li>
<li><code>Generator.prototype.return()</code></li>
<li><code>Generator.prototype.throw()</code></li>
<li><code>yield*</code></li>
</ul>
<h6 id="c-详解-1"><a href="#c-详解-1" class="headerlink" title="c. 详解"></a>c. 详解</h6><ul>
<li><p><code>Generator</code> 函数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'!'</span>;</div><div class="line">	<span class="keyword">return</span> <span class="string">'func end'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> helloWorld = test();</div></pre></td></tr></table></figure>
<p>  上面的例子就是一个简单的 <code>Generator</code> 函数，可以发现，函数声明是多个一个 <code>*</code>，并且函数体内出现了多个 <code>yield</code> 语句和 <code>return</code> 语句，即该生成器函数存在四种迭代状态： <code>hello</code> <code>world</code> <code>!</code> <code>return</code></p>
<p>  但是当我们执行上述代码的时候，发现并没有即时的执行，返回的也不是它的执行结果，而是一个生成器对象，只有当调用这个生成器对象的 <code>next</code> 方法，才会依次的执行函数语句，直到遇到 <code>yield</code> 语句或 <code>return</code> 语句。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "hello", done: false&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "world", done: false&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "!", done: false&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: "func end", done: true&#125;</span></div><div class="line">helloWorld.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>  <img src="./1.png" style="margin-left: 0;"></p>
<p>  让我们梳理一下上述代码的执行流程。  </p>
<p>  第一次调用 <code>next</code>： 生成器函数开始执行，遇到 <code>yield</code> 语句，暂停执行。<code>next</code> 返回一个对象，其中将当前 <code>yeild</code> 语句的值 <code>hello</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>false</code>，迭代未结束。</p>
<p>  第二次调用 <code>next</code>： 从上一个 <code>yield</code> 语句开始执行，遇到 <code>yield</code> 语句，暂停执行。<code>next</code> 返回一个对象，其中将当前 <code>yeild</code> 语句的值 <code>world</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>false</code>，迭代未结束。</p>
<p>  第三次调用 <code>next</code>： 从上一个 <code>yield</code> 语句开始执行，遇到 <code>yield</code> 语句，暂停执行。<code>next</code> 返回一个对象，其中将当前 <code>yeild</code> 语句的值 <code>!</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>false</code>，迭代未结束。</p>
<p>  第四次调用 <code>next</code>： 从上一个 <code>yield</code> 语句开始执行，遇到 <code>return</code> 语句，结束执行。<code>next</code> 返回一个对象，其中将当前 <code>return</code> 语句的值 <code>func end</code> 作为返回对象的 <code>value</code> 字段。<code>done</code> 字段为 <code>true</code>，迭代结束。</p>
<p>  第五次调用 <code>next</code>： 生成器函数已经迭代（运行）完毕，<code>next</code> 方法始终返回 <code>{value: undefined, done: true}</code></p>
<p>  让我们再用一个例子来了解一下 <code>yield</code> 语句的执行流程：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'func start'</span>);</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(i &lt; <span class="number">6</span>)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'yield start'</span>);</div><div class="line">		<span class="keyword">yield</span> i;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'yield end'</span>); </div><div class="line">		i++;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'func end'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div></pre></td></tr></table></figure>
<p>  <img src="./2.png" style="margin-left: 0;"></p>
<p>  首次调用 <code>next</code> ，函数开始执行，遇到 <code>yield</code> 暂停执行，将 <code>yield</code> 语句后的表达式运行后返回，当作 <code>next</code> 方法返回值的 <code>value</code> 字段，依次调用 <code>next</code> ，从上次 <code>yield</code> 处继续运行，直到遇到下一个 <code>yield</code>，循环往复。  </p>
</li>
<li><p><code>yield</code> 语句</p>
<p>  通过上面的例子， <code>yield</code> 语句的特性已经很明显：  </p>
<ul>
<li><p><code>yield</code> 语句会暂停生成器函数的执行</p>
</li>
<li><p><code>yield</code> 语句后表达式的运行结果将作为 <code>next</code> 语句返回值中的 <code>value</code> 字段</p>
</li>
</ul>
</li>
<li><p><code>Generator.prototype.next()</code></p>
<p>  <code>next</code> 语句的返回值有两个字段 <code>value</code> 和 <code>done</code> ，<code>value</code> 为当前 <code>next</code> 指向的 <code>yield</code> 语句的返回值，<code>done</code> 标识当前生成器函数是否迭代完毕。  </p>
<p>  <code>next</code> 方法还可以接受任意一个参数，该参数将作为上一个 <code>yield</code> 返回值。 </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params">i</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">		<span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</div><div class="line">		<span class="keyword">if</span>(reset)&#123;</div><div class="line">			i = reset;</div><div class="line">		&#125;</div><div class="line">		i++;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div><div class="line"></div><div class="line">genEx.next();  <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">genEx.next();  <span class="comment">// &#123;value: 2, done: false&#125;</span></div><div class="line">genEx.next(<span class="number">10</span>);  <span class="comment">// &#123;value: 11, done: false&#125;</span></div></pre></td></tr></table></figure>
<p>  上面的代码实现了一个无限的迭代器，在每次运行到 <code>yield</code> 语句时，如果调用指向此次 <code>yield</code> 语句的 <code>next</code> 方法没有参数，那么 <code>reset</code> 的值始终是 <code>undefined</code>。只有在调用 <code>next</code> 方法传入了参数，此次执行 <code>yield</code> 语句时，<code>yield</code> 语句的返回值将变为 <code>next</code> 传入的参数。这样的特性能够让我们用同步的方式写出异步执行的代码，具体例子下文。  </p>
</li>
<li><p><code>Generator.prototype.return()</code></p>
<p>  当我们想在外部结束生成器函数的迭代，可以使用 <code>return</code> 方法，并将 <code>return</code> 方法的参数作为返回值。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div><div class="line"></div><div class="line">genEx.next();  <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">genEx.return(<span class="string">'end'</span>);  <span class="comment">// &#123;value: 'end', done: true&#125;</span></div><div class="line">genEx.next();  <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Generator.prototype.return()</code></p>
<p>  <code>throw</code> 方法允许我们在生成器函数外部抛出错误，并在内部捕获。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		<span class="keyword">yield</span>;</div><div class="line">	&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'inner error: '</span> + e);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen();</div><div class="line">genEx.next();</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">	genEx.throw(<span class="string">'a'</span>);</div><div class="line">	genEx.throw(<span class="string">'b'</span>);</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'outer error: '</span> + e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// inner error: a</span></div><div class="line"><span class="comment">// outer error: b</span></div></pre></td></tr></table></figure>
<p>  第一次抛出错误，被生成器函数捕获到，第二次再抛出，由于 <code>catch</code> 语句已经在第一次执行过了，所以内部无法再次捕获错误，从而在外部的 <code>try catch</code> 语句中可以捕获到错误。  </p>
</li>
<li><p><code>yield*</code></p>
<p>  如果想在生成器函数中调用另一个生成器函数，将会用到 <code>yield*</code> 语句。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen1 = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'1'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'2'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> gen2 = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'a'</span>;</div><div class="line">	<span class="keyword">yield</span>* gen1();</div><div class="line">	<span class="keyword">yield</span> <span class="string">'b'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> genEx = gen2();</div><div class="line"></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "a", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "1", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "2", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: "b", done: false&#125;</span></div><div class="line">genEx.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="d-实际应用-1"><a href="#d-实际应用-1" class="headerlink" title="d. 实际应用"></a>d. 实际应用</h6><ul>
<li><p>异步 <code>Ajax</code> 请求</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params">url</span>)</span>&#123;</div><div class="line">	<span class="comment">// fetch: 原生的ajax请求API</span></div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</div><div class="line">	<span class="built_in">console</span>.log(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> genEx = gen(<span class="string">'https://api.github.com/users/github'</span>);</div><div class="line"><span class="keyword">var</span> result = genEx.next();</div><div class="line"></div><div class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res);</div><div class="line">	<span class="keyword">return</span> res.json();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">	genEx.next(data.bio);  <span class="comment">// How people build software.</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  上面的代码中，第一次调用 <code>next</code> 方法，开始请求，拿到返回结果后，用结果中的 <code>value</code>（ <code>fetch</code> 返回的是一个 <code>Promise</code>，所以需要 <code>then</code> 方法调用），调用下一次 <code>then</code> 从而执行生成器函数中 <code>yield</code> 后面的代码。  </p>
<p>  可以看出，虽然生成器函数将异步操作表示的很简洁，但是流程管理并不是很直接，即何时执行第一阶段，何时执行第二阶段并不能很好的向使用者展示。  </p>
</li>
</ul>
<h4 id="3、Async-Await"><a href="#3、Async-Await" class="headerlink" title="3、Async/Await"></a>3、Async/Await</h4><p>从回调，到 <code>Promise</code>，再到 <code>Generator</code> 函数，js的异步流程控制一直在进化，但是每种解决方法都无形的增加了额外的复杂度，都需要理解底层的运行机制才能很好的运用。  </p>
<p>而 <code>ES7</code> 提出的 <code>Async/Await</code>，大概也许可能是 JavaScript 中最好的异步解决方案。  </p>
<h6 id="a-实例"><a href="#a-实例" class="headerlink" title="a. 实例"></a>a. 实例</h6><ul>
<li><p>异步读取文件</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">// 与上文一致</span></div><div class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span>(err) &#123;</div><div class="line">				reject(err);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				resolve(data);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用</span></div><div class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> file1 = <span class="keyword">await</span> readFile(<span class="string">'./test1.json'</span>);</div><div class="line">	<span class="keyword">var</span> file2 = <span class="keyword">await</span> readFile(<span class="string">'./test2.json'</span>);</div><div class="line">	<span class="built_in">console</span>.log(file1);</div><div class="line">	<span class="built_in">console</span>.log(file2);	</div><div class="line">&#125;</div><div class="line">asyncReadFile();</div></pre></td></tr></table></figure>
<p>  如果把上面的代码写成 <code>Geneerator</code> 风格，你会发现两者很相似。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> asyncReadFile = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'./test1.json'</span>);</div><div class="line">	<span class="keyword">var</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'./test2.json'</span>);</div><div class="line">	<span class="built_in">console</span>.log(file1);</div><div class="line">	<span class="built_in">console</span>.log(file2);	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  对比之后，其实 <code>async</code> 函数就是把 <code>*</code> 替换成 <code>async</code>，把 <code>yield</code> 替换成 <code>await</code>。  </p>
<p>  可以说，<code>async</code> 其实就是对 <code>Geneerator</code> 的语法糖，只不过多包了一层，改进了很多。  </p>
<p>  第一，使用 <code>async</code> 函数不用再手动的调用 <code>next</code> 方法来执行每一次迭代</p>
<p>  第二，更好的语义，<code>async</code> 表示这个函数是一个异步函数，<code>await</code> 表示此后的操作需要等待此步操作完成</p>
<p>  第三，侵入性更低，原生的 <code>try catch</code> 语句能处理错误，<code>async</code> 函数中的 <code>await</code> 语句不用做特殊处理，<code>Promise</code> 可以，原始的同步操作也可以  </p>
<p>  第四，更直观、更灵活的调用，<code>async</code> 函数返回的是一个 <code>Promise</code> 对象，异步操作完成后可以直接用 <code>then</code> 方法进行下一步操作  </p>
<p>  第五，简单的API，只有 <code>async</code> 和 <code>await</code> 两个API，<code>async</code> 用来声明一个异步函数，<code>await</code> 用来等待一个异步操作  </p>
</li>
<li><p><code>sleep</code> 函数</p>
<p>  上文我们用 <code>Promise</code> 实现了一个异步风格的 <code>sleep</code> 函数，现在让我们看看如何用同步的风格实现并使用它。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span>(<span class="params">ms</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		setTimeout(resolve, ms)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sleepEx = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'begin'</span>);</div><div class="line">	<span class="keyword">await</span> sleep(<span class="number">1000</span>);</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'end after 1000ms'</span>);</div><div class="line">&#125;</div><div class="line">sleepEx();</div></pre></td></tr></table></figure>
<p>  完美～</p>
</li>
</ul>
<h6 id="b-如何使用"><a href="#b-如何使用" class="headerlink" title="b. 如何使用"></a>b. 如何使用</h6><p><code>async</code> <code>await</code> 特性属于ES7的新特性，目前的ES运行环境中并没有实现这样的功能，但是借助 <code>babel</code>，我们可以很方便的使用这些新特性。  </p>
<p>这个展开讲又是一个大话题～贴一个 <code>bable</code> 转换代码的网址：<a href="https://babeljs.io/repl/#?evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Cstage-0" target="_blank" rel="external">Babel transform online</a>  </p>
<p>如何在线下使用，自行谷歌，或者，再来一篇？哈哈  </p>
<h3 id="五、结束"><a href="#五、结束" class="headerlink" title="五、结束"></a>五、结束</h3><p>长长的文章终于结束了，呼～  </p>
<p>主要的目的就是对异步流程的解决方案进行一下梳理，加深对js异步特性的理解。最推荐的方式还是ES7的新特性，毕竟是既有的新标准，使用的过程还能学习下 <code>babel</code> 的配置，哈哈。</p>
</div></article></div></section><footer><div class="paginator"><a href="/blog/2016/06/23/我的sublime配置/" class="prev">上一篇</a><a href="/blog/2016/06/05/会声会影安装与激活/" class="next">下一篇</a></div><div data-thread-key="2016/06/09/js中的异步流程控制-Promise-Generators-Async-Await/" data-title="js中的异步流程控制--Promise/Generator/Async/Await" data-url="https://luoyefe.com/blog/blog/2016/06/09/js中的异步流程控制-Promise-Generators-Async-Await/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"luoye-fe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="https://luoyefe.com/blog">Luoye</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-78104533-1",'auto');ga('send','pageview');var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?213cc17b8240ff47d16b1b3aa9dbe0ad";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>
<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> webpack-workflow · LUOYE</title><meta name="description" content="webpack-workflow - Luoye"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="https://luoyefe.com" target="_blank" class="nav-list-link">INDEX</a></li><li class="nav-list-item"><a href="/blog" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/luo-ye-42-22" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="https://github.com/luoye-fe" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">webpack-workflow</h1><div class="post-info">2016年5月24日</div><div class="post-content"><h2 id="前端工作流中要解决的问题"><a href="#前端工作流中要解决的问题" class="headerlink" title="前端工作流中要解决的问题"></a>前端工作流中要解决的问题</h2><ul>
<li>资源管理：模块化、组件化、依赖管理等</li>
<li>开发流程：dev、debug、proxy、build、deploy</li>
<li>周边工具：图形化界面、命令行辅助、自动化工程</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><a href="http://webpack.github.io/" target="_blank" rel="external">webpack官网</a>  </li>
<li>Webpack 是当下最热门的前端资源模块化管理和打包工具。它  <ul>
<li>能把散碎的静态资源通过一定的规则打包在一起  </li>
<li>还可以require几乎所有的静态资源，包括但不限于CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS、 Vue、 Jade、Ejs 等等  </li>
<li>还可以将代码切割成不同的chunk，实现按需加载，异步加载</li>
<li>还可以极精细的控制所有静态资源的版本  </li>
<li>还可以实现代码热替换，开发模式下，不用刷新浏览器，不用实时编译，自身的socket-io已经把内存中的代码换成最新的  </li>
<li>还可以 <code>SourceUrls</code> 和 <code>SourceMaps</code>，易于调试</li>
<li>还可以和前端最新的技术栈完美融合（Vue、React），针对这两个在webpack中有一整套的工具链  </li>
<li>还可以使用 <code>Plugin</code> 插件，实现各种定制化任务  </li>
<li>还可以和 <code>gulp/grunt</code> 等构建工具协同作战，完成极其复杂的任务  </li>
<li>还原生支持增量编译，发布代码再也不用等个好几分钟  </li>
</ul>
</li>
</ul>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><ul>
<li><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>  用 <code>webpack</code> 来做模块化，简直神器。  </p>
<p>  前端的模块化一直是一个很受人关注的问题，不同的加载器实现方式都不一样。<code>lithe/requireJs/seaJs</code>，这样的预加载器都有自己的一套实现方式，一定程度上解决了js的模块化问题，但是不同的实现方式，让我们不得不对不同的库做兼容性处理，让加载器能够识别，无疑增加了工作量和降低了模块的通用度。即使现在ES6提出了统一的标准，但是离实际使用还有很长的距离。  </p>
<p>  所以，有一个足够灵活，足够强大的模块加载器是个必要的选择。  </p>
<p>  在 <code>webpack</code> 中，同时支持 CommonJS、AMD和ES6，灵活性有保证。  </p>
<p>  并且在 <code>webpack</code> 的设计理念中，所有的静态资源都是模块，所以借助强大的 <code>loader</code> 系统几乎可以加载任意类型的静态资源，并且对模块的输出结果可以做非常精细的控制，根据不同的配置可以达到任意想要的结果。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">loaders: [&#123;</span><br><span class="line">    test: <span class="regexp">/.js$/</span>,</span><br><span class="line">    loader: <span class="string">'jsx-loader?harmony'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    test: <span class="regexp">/.vue$/</span>,</span><br><span class="line">    loader: <span class="string">'vue-loader'</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    test: <span class="regexp">/.css$/</span>,</span><br><span class="line">    loader: <span class="string">'style-loader'</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">	test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/i</span>,</span><br><span class="line">	loaders: [</span><br><span class="line">	    <span class="string">'image?&#123;bypassOnDebug: true, progressive:true, optimizationLevel: 3, pngquant:&#123;quality: "65-80"&#125;&#125;'</span>,</span><br><span class="line">	    <span class="string">'url?limit=10000&amp;name=img/[hash:8].[name].[ext]'</span>,</span><br><span class="line">	]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>  这是 <code>webpack</code> 配置文件中的 <code>loaders</code> 部分，其中，<code>test</code> 是正则匹配，匹配到的文件将使用相应的 <code>loader</code> 去解析，然后这些文件就成为了模块，可以在其它地方引用。比如：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">// 加载js</span></span><br><span class="line"><span class="keyword">var</span> login = <span class="built_in">require</span>(<span class="string">'./src/js/conf/login/login.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// js文件会被webpack包装，并赋予单独ID，exports出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载css</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./src/css/login.css'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// css文件会被以style标签插入到head中，当然，也可以通过ExtractTextPlugin这样的插件以link标签插入到页面中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载图片</span></span><br><span class="line"><span class="keyword">var</span> btnImg = <span class="built_in">require</span>(<span class="string">'./src/img/btn.png'</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = btnImg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据上面的配置，小于10k的图片直接dataurl到src中，并且打包后自动添加hash值，当然，在js中引用，hash值部分也相应的会变化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载vue单文件组件</span></span><br><span class="line"><span class="keyword">var</span> loginCom = <span class="built_in">require</span>(<span class="string">'./src/js/components/login.vue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue有单独的loader读取vue单文件组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有模块的加载可以做很多灵活的配置，比如，文件hash值、小于一定大小的图片dataurl、打包后文件命名等</span></span><br><span class="line"><span class="comment">// jade模版，ejs模版，less文件，sass文件都可以直接require，不用预编译，直接用！</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>  抛开现在流行的组件化解决方案，光以 <code>webpack</code> 的角度来看，如果模版，样式，脚本，都可以作为模块来引入，这就使得封装组件变的很简单。比如：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索组件</span></span><br><span class="line"><span class="comment">// js/component/search/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'js/component/search/index.css'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tpl = <span class="built_in">require</span>(<span class="string">'js/component/search/template.ejs'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlStr = tpl(&#123;searchContent: options.searchStr&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> launchSearch = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	launchSearch: launchSearch,</span><br><span class="line">	somethingelse: <span class="string">'balabala'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  使用：  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js/app.js</span></span><br><span class="line"><span class="keyword">var</span> searchComponent = <span class="built_in">require</span>(<span class="string">'js/component/search/index.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">	searchStr: <span class="string">'水果'</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">searchComponent.launchSearch(options);</span><br></pre></td></tr></table></figure>
<p>  这样的开发方式无疑能够极大降低维护成本，当然，如果和现在流行的前端框架，如React、Vue结合起来实现组件化，代码组织会更加清晰，自由度也更高，展开讲又是一个大话题，按下不表。  </p>
<p>  还是贴一下伪代码吧。。以 <code>Vue</code> 为例  </p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// alert.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class="alert" v-show="alertConfig.show" :class="alertConfig.type" transition="fade"&gt;</span><br><span class="line">        &lt;h4&gt;&#123;&#123;alertConfig.msg&#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">// css 样式</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Vue = require('Vue');</span><br><span class="line"></span><br><span class="line">var Alert = Vue.extend(&#123;</span><br><span class="line">    name: 'Alert',</span><br><span class="line">    prop: ['alertConfig']</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = Alert;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>  使用  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.vue（同样是一个组件，可能被其它组件（如根组件）依赖）</span></span><br><span class="line"></span><br><span class="line">&lt;templeate&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">m-alert</span> <span class="attr">:alert-config</span>=<span class="string">"alertConfig"</span>&gt;</span><span class="tag">&lt;/<span class="name">m-alert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'Vue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Alert = <span class="built_in">require</span>(<span class="string">'alert.vue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Main = Vue.extend(&#123;</span><br><span class="line">    name: <span class="string">'Main'</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> &#123;</span><br><span class="line">    		alertConfig: &#123;</span><br><span class="line">    			show: <span class="literal">false</span>,</span><br><span class="line">    			type: <span class="string">'info'</span>, <span class="comment">// info/success/warning/erro</span></span><br><span class="line">    			msg: <span class="string">'提示信息'</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    	<span class="string">'m-alert'</span>: Alert</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Main;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>  这样的 <code>.vue</code> 组件通过 <code>webpack</code> 中的 <code>vue-loader</code> 插件就可以完成打包。  </p>
</li>
</ul>
<ul>
<li><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>  没有什么好说的。。。<code>npm</code>。<br>  毕竟绝大部分的流行库都在 <code>npm</code> 上，也都支持模块加载的方式。不排除有一些纯js库（jq插件）需要手动封装下。其实也很简单，如果都遵循 <code>CommonJs</code> 的加载方式，而且其中没有其它依赖的话，直接 <code>require</code> 即可，如果有依赖，大部分也是 <code>jq</code> 等，在文件最前面声明下 <code>var $ = require(&#39;jQuery&#39;)</code> 即可。<br>  这样，一个工程只需要维护一份 <code>package.json</code> ，不管是开发用的包，还是构建用的包都可以统一管理。  </p>
</li>
</ul>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>对于前端的开发流程，一直的想法是，我们能有一个统一的入口工具，不管是命令行还是图形化界面，可以把调试，代理，构建等一系列操作整合起来，并且尽可能的简化这样的操作，开发不用过多的关注构建问题，也不用为调试、构建浪费更多的精力。</p>
<ul>
<li><h3 id="dev、debug"><a href="#dev、debug" class="headerlink" title="dev、debug"></a>dev、debug</h3><p>  基于 <code>webpack</code> 的开发流程主要有两种方式：  </p>
<ul>
<li><p><code>webpack</code> 的实时构建模式  </p>
<p>  <code>webpack --watch</code> 每次修改代码都会实时的构建，增量的，很快，即使是用了 <code>uglify</code> 实时构建压缩也很快（不超过1s）  </p>
</li>
<li><p><code>webpack-dev-server</code>  </p>
<p>  <code>webpack-dev-server</code> 是一个小型的 <code>express</code> 服务器，它的原理就是使用 <code>webpack-dev-middleware</code> 中间件来为通过 <code>webpack</code> 生成的静态资源提供web服务。它的内部通过 <code>socket.io</code> 连接客户端，可以实时发送编译状态的信息到客户端，从而达到客户端代码的实时热更新，也就是 <code>HMR</code> <code>Hot Module Replacement</code>。  </p>
<p>  <code>webpack-dev-server</code> 支持命令行模式和 <code>NodeJs</code> 模式，命令行模式就是直接打开 <code>webpack-dev-server</code> 本地服务器，参数默认，配置灵活性稍低，但是简单快捷，如下：  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// --line 行内模式 | --hot 热替换</span><br><span class="line">webpack-dev-server --line --hot</span><br></pre></td></tr></table></figure>
<p>  在项目根目录行执行上面的命令之后，本地的 <code>webpack-dev-server</code> 服务器已经启动，此目录下的由 <code>webpack</code> 生成的静态资源都将被这个本地服务器托管。  </p>
<p>  以 GoH5 为例，把页面内引用的资源改为 <code>8080</code> 端口下对应的文件并加入 <code>http://localhost:8080/webpack-dev-server.js</code>，此时代码热更新已经生效：  </p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"GoH5，一款可视化的H5编辑器，拖拽、动画、事件，神奇的H5。"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"H5,可视化,cms,编辑器"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go H5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"/back/dist/css/goh5.min.css?ver=1.0.3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/webpack-dev-server.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/vendor.min.js?ver=1.0.3"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/goh5.min.js?ver=1.0.3"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 因为我的应用服务启动在 3030 端口，所以这里的地址写了绝对地址，如果同端口，直接写文件名即可</span><br></pre></td></tr></table></figure>
<p>  在控制台可以看到  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HMR] Vue component hot reload shim applied. // 不同的热重载提示信息不同（Vue/React）</span><br><span class="line">[WDS] Hot Module Replacement enabled.</span><br></pre></td></tr></table></figure>
<p>  如果本地修改了代码可以看到  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[WDS] App updated. Recompiling...</span><br><span class="line">[WDS] App hot update...</span><br></pre></td></tr></table></figure>
<p>  同时，控制台也会输出相关的编译信息：  </p>
<p>  <img src="./1.png" alt="控制台"></p>
<p>  一个字。。。快。。。而且，浏览器并不用刷新呀 (有一定限定条件，并不是一切代码都可以热重载)  </p>
<p>  放一张官网的gif  </p>
<p>  <img src="http://blog.evanyou.me/images/vue-hot.gif" alt="hot-reload"></p>
<p>  上面的例子主要集中在Vue上，其实大同小异，并且 <code>webpack</code> 提供了 <code>webpack-dev-middleware</code> 中间件，可以定制一个本地的服务，完成很多任务。</p>
</li>
</ul>
</li>
</ul>
<h4 id="所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。"><a href="#所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。" class="headerlink" title="所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。"></a><strong>所以我觉得，前端的开发流程如果有一个统一的本地服务，可能性无极限。</strong></h4><ul>
<li><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>  线上代码的代理调试，借助 <code>host</code>，借助 <code>Fiddler</code>，借助 <code>wamp</code>，其实。。  </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/some/path*'</span>: &#123;</span><br><span class="line">                target: <span class="string">'https://js.meixincdn.com'</span>,</span><br><span class="line">                secure: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当然，这样的代理不够灵活，而且不能代理html，但是如果借助本地的服务，我们可以这么做   </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先行配置host，可以手动，也可以像 `fd-server` 有个图形化界面，然后  </span></span><br><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'koa-proxy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = koa();</span><br><span class="line"></span><br><span class="line">app.use(proxy(&#123;</span><br><span class="line">  	host: <span class="string">'https://localhost:8080/'</span>,</span><br><span class="line">  	match: <span class="regexp">/\/js.meixincdn.com\//</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>  上面达到的功能就是把 <code>js.meixincdn.com</code> 域名的资源转发到 <code>webpack-dev-server</code> ，然后就可以愉快的开始开发了  </p>
</li>
</ul>
<ul>
<li><h3 id="build、deploy"><a href="#build、deploy" class="headerlink" title="build、deploy"></a>build、deploy</h3><p>  这一块我的想法还是，放到测试机上去。。  </p>
<p>  测试机上可以跑一个 <code>gulp watch</code> 和 <code>webpack --watch</code> 的任务，本地提交了 <code>src</code> 目录下的文件，测试机检测到文件更新，直接编译，这样的编译都是增量的，肯定很快，然后再该怎么上线怎么上线，怎么发布怎么发布。本地就可以直接忽略 <code>dist</code> 目录的改变，不提交其中的内容。  </p>
<p>  还有一点，我是觉得 php 的 smarty 模版可以前端维护，就算不行，静态资源那一块也一定前端维护，这样不管是改时间戳还是直接hash，都很灵活啊～  </p>
</li>
</ul>
<h2 id="周边工具"><a href="#周边工具" class="headerlink" title="周边工具"></a>周边工具</h2><p>图形化界面、命令行辅助、自动化工程，高大上的整套解决方案，想想就激动。。。  </p>
</div></article></div></section><footer><div class="paginator"><a href="/blog/2016/06/05/会声会影安装与激活/" class="prev">上一篇</a><a href="/blog/2016/04/12/use-webpack-in-your-node-app/" class="next">下一篇</a></div><div data-thread-key="2016/05/24/webpack-workflow/" data-title="webpack-workflow" data-url="https://luoyefe.com/blog/blog/2016/05/24/webpack-workflow/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"luoye-fe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="https://luoyefe.com/blog">Luoye</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-78104533-1",'auto');ga('send','pageview');var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?213cc17b8240ff47d16b1b3aa9dbe0ad";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>